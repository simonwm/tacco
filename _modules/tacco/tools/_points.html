<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tacco.tools._points &mdash; TACCO  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=ad0ac74c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/readthedocs-custom.css?v=c8300288" />
      <link rel="stylesheet" type="text/css" href="../../../_static/notebook_hacks.css?v=e4ce2130" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html">
            
              <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/tacco.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">TACCO</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tacco.tools._points</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tacco.tools._points</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">anndata</span> <span class="k">as</span> <span class="nn">ad</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.csgraph</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span>
<span class="kn">import</span> <span class="nn">sklearn.cluster</span>
<span class="kn">import</span> <span class="nn">sklearn.linear_model</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">_math</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">preprocessing</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">get</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_helper</span> <span class="k">as</span> <span class="n">helper</span>

<span class="c1">#@njit(fastmath=True)</span>
<span class="k">def</span> <span class="nf">_map_types</span><span class="p">(</span><span class="n">cht_indptr</span><span class="p">,</span> <span class="n">cht_indices</span><span class="p">,</span> <span class="n">cht_data</span><span class="p">,</span> <span class="n">point_hashes</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="n">point_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">point_hashes</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">cht_hash</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cht_indptr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">ptr_start</span> <span class="o">=</span> <span class="n">cht_indptr</span><span class="p">[</span><span class="n">cht_hash</span><span class="p">];</span>
        <span class="n">ptr_end</span>   <span class="o">=</span> <span class="n">cht_indptr</span><span class="p">[</span><span class="n">cht_hash</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="n">ptr_start</span> <span class="o">==</span> <span class="n">ptr_end</span><span class="p">:</span> <span class="c1"># no data for this hash</span>
            <span class="k">continue</span>
        
        <span class="k">while</span> <span class="n">point_hashes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cht_hash</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;map_types got unfiltered and/or unsorted input??&#39;</span><span class="p">)</span>
            <span class="n">point_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># -1 means &#39;no type&#39; # should not happen, due to filter outside</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># point_hashes[i] == cht_hash is now guaranteed, as cht hashes are a subset of rna hashes</span>
        
        <span class="k">for</span> <span class="n">ptr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ptr_start</span><span class="p">,</span> <span class="n">ptr_end</span><span class="p">):</span>
            <span class="n">cht_type</span> <span class="o">=</span> <span class="n">cht_indices</span><span class="p">[</span><span class="n">ptr</span><span class="p">];</span>
            <span class="n">cht_count</span> <span class="o">=</span> <span class="n">cht_data</span><span class="p">[</span><span class="n">ptr</span><span class="p">];</span>
            
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cht_count</span><span class="p">):</span>
                <span class="n">point_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cht_type</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">point_types</span>

<span class="k">def</span> <span class="nf">_map_hash_annotation</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">abcdata</span><span class="p">,</span>
    <span class="n">annotation_key</span><span class="p">,</span>
    <span class="n">hash_key</span><span class="o">=</span><span class="s1">&#39;hash&#39;</span><span class="p">,</span>
    <span class="n">count_key</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span>
    <span class="n">result_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Maps annotation from annotated binned count data to unbinned data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data</span>
<span class="sd">        A :class:`~pandas.DataFrame` containing the unbinned data in long</span>
<span class="sd">        format.</span>
<span class="sd">    abcdata</span>
<span class="sd">        A :class:`~pandas.DataFrame` containing annotated binned count data</span>
<span class="sd">        in long format.</span>
<span class="sd">    annotation_key</span>
<span class="sd">        The key containing the categorical annotation to map in `abcdata`.</span>
<span class="sd">    hash_key</span>
<span class="sd">        The key which identifies corresponding entries in `data` and</span>
<span class="sd">        `abcdata`.</span>
<span class="sd">    count_key</span>
<span class="sd">        The key corresponding to observation counts/weights in `abcdata`.</span>
<span class="sd">    result_key</span>
<span class="sd">        The key to contain the mapped annotation in `data`. If `None`, a</span>
<span class="sd">        :class:`~pandas.Series` containing the mapped annotation is returned.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Depending on `result_key` returns either a :class:`~pandas.Series` of\</span>
<span class="sd">    annotation assignments or the updated input `data` contining the\</span>
<span class="sd">    assignments under `result_key`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># make hash keys compatible</span>
    <span class="n">point_hashes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">hash_key</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">point_hashes</span><span class="p">,</span> <span class="s1">&#39;cat&#39;</span><span class="p">):</span>
        <span class="n">point_hashes</span> <span class="o">=</span> <span class="n">point_hashes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
    <span class="n">bin_hashes</span> <span class="o">=</span> <span class="n">abcdata</span><span class="p">[</span><span class="n">hash_key</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bin_hashes</span><span class="p">,</span> <span class="s1">&#39;cat&#39;</span><span class="p">):</span>
        <span class="n">bin_hashes</span> <span class="o">=</span> <span class="n">bin_hashes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
    <span class="n">unavailable</span> <span class="o">=</span> <span class="n">bin_hashes</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">[</span><span class="o">~</span><span class="n">bin_hashes</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">point_hashes</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unavailable</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;hashes in `data` and `abcdata` are not compatible: `abcdata[&quot;</span><span class="si">{</span><span class="n">hash_key</span><span class="si">}</span><span class="s1">&quot;]` contained the hashes </span><span class="si">{</span><span class="n">unavailable</span><span class="si">}</span><span class="s1">, which were not found in `data[&quot;</span><span class="si">{</span><span class="n">hash_key</span><span class="si">}</span><span class="s1">&quot;]`! Maybe the dtypes do not match and e.g. one is str and the other int?&#39;</span><span class="p">)</span>
    <span class="n">point_hashes</span> <span class="o">=</span> <span class="n">point_hashes</span><span class="p">[</span><span class="n">point_hashes</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">bin_hashes</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">)]</span> <span class="c1"># it is OK to have some hashes not recieve any annotation</span>
    <span class="n">bin_hashes</span> <span class="o">=</span> <span class="n">bin_hashes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">point_hashes</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># use the identical categorical type to be certain that the .cat.codes are compatible</span>
    
    <span class="c1"># get bin*annotation anndata with number of annotated entitites in .X</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dataframe2anndata</span><span class="p">(</span><span class="n">abcdata</span><span class="p">,</span> <span class="n">obs_key</span><span class="o">=</span><span class="n">bin_hashes</span><span class="p">,</span> <span class="n">var_key</span><span class="o">=</span><span class="n">annotation_key</span><span class="p">,</span> <span class="n">count_key</span><span class="o">=</span><span class="n">count_key</span><span class="p">)</span> <span class="c1"># the hash .cat.codes ~ rows in adata are ordered by construction</span>

    <span class="n">point_hashes</span> <span class="o">=</span> <span class="n">point_hashes</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span> <span class="c1"># ordered hashes are assumed in the numba part; sorting conserves mapping of entity to hash via the index</span>

    <span class="n">sum0</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sum1</span> <span class="o">=</span> <span class="n">point_hashes</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">point_hashes</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">))]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">sum0</span><span class="o">-</span><span class="n">sum1</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The hashed in `data` and `absdata` are not 1-to-1 mappable! In case this is the result of `split_observation`, a smaller stopping criterion `delta` could help...&#39;</span><span class="p">)</span>
    
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">min_dtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">point_annotation</span> <span class="o">=</span> <span class="n">_map_types</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">point_hashes</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># map back from numbers to annotation</span>
    <span class="n">point_annotation</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">point_annotation</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">abcdata</span><span class="p">[</span><span class="n">annotation_key</span><span class="p">],</span> <span class="s1">&#39;cat&#39;</span><span class="p">):</span>
        <span class="n">point_annotation</span> <span class="o">=</span> <span class="n">point_annotation</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">abcdata</span><span class="p">[</span><span class="n">annotation_key</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">point_annotation</span> <span class="o">=</span> <span class="n">point_annotation</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">abcdata</span><span class="p">[</span><span class="n">annotation_key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">del</span> <span class="n">adata</span> <span class="c1"># clean up</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span> <span class="c1"># anndatas are not well garbage collected and accumulate in memory</span>

    <span class="n">point_annotation</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">point_annotation</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">point_hashes</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="c1"># reindex result to conform with the input</span>

    <span class="k">if</span> <span class="n">result_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">point_annotation</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">result_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">point_annotation</span>
        <span class="k">return</span> <span class="n">data</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_strip_distance_matrix</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="n">new_row</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="n">new_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span><span class="p">)</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># only take the upper triangular part and mirror it later</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">col</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">max_distance</span><span class="p">:</span>
            <span class="n">new_row</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">new_col</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">new_data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">new_row</span><span class="p">[</span><span class="n">c</span><span class="p">:(</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_col</span><span class="p">[:</span><span class="n">c</span><span class="p">]</span>
    <span class="n">new_col</span><span class="p">[</span><span class="n">c</span><span class="p">:(</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_row</span><span class="p">[:</span><span class="n">c</span><span class="p">]</span>
    <span class="n">new_data</span><span class="p">[</span><span class="n">c</span><span class="p">:(</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">[:</span><span class="n">c</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">new_row</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">new_col</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">new_data</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
<span class="k">def</span> <span class="nf">strip_distance_matrix</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`distance` has to be a `scipy.sparse.coo_matrix`!&#39;</span><span class="p">)</span>
    <span class="n">distance</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">distance</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">distance</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">_strip_distance_matrix</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">distance</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">distance</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">)</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_update_submatrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="n">indy</span><span class="p">):</span>
    <span class="n">n_x</span><span class="p">,</span> <span class="n">n_y</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">n_x</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indx</span><span class="p">))</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">n_y</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indy</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_y</span><span class="p">):</span>
            <span class="n">M</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">indx</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>

<div class="viewcode-block" id="distance_matrix">
<a class="viewcode-back" href="../../../_autosummary/tacco.tools.distance_matrix.html#tacco.tools.distance_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">distance_matrix</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span>
    <span class="n">max_distance</span><span class="p">,</span>
    <span class="n">position_key</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">],</span>
    <span class="n">base_distance_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">result_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">annotation_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">annotation_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">distance_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">annotation_distance_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">coo_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">low_mem</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kw_args</span><span class="p">,</span>
<span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Calculates a sparse or dense distance matrix.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata</span>
<span class="sd">        A :class:`~anndata.AnnData`</span>
<span class="sd">    max_distance</span>
<span class="sd">        The maximum distance to calculate. All larger distances are unset in</span>
<span class="sd">        the result (which acts as a `0` for sparse matrices...). `None` and</span>
<span class="sd">        `np.inf` result in dense distance computation (which can be infeasible</span>
<span class="sd">        for larger datasets).</span>
<span class="sd">    position_key</span>
<span class="sd">        The `.obsm` key or array-like of `.obs` keys with the position space</span>
<span class="sd">        coordinates</span>
<span class="sd">    base_distance_key</span>
<span class="sd">        The `.obsp` key containing a precomputed distance matrix to update with</span>
<span class="sd">        annotation distance. If `None`, the distances are recomputed with the</span>
<span class="sd">        positions found in `position_key`. Otherwise `position_key` is ignored.</span>
<span class="sd">        If `.obsp[base_distance_key]` does not exist, the distances are also</span>
<span class="sd">        recomputed and then written to `.obsp[base_distance_key]`.</span>
<span class="sd">    result_key</span>
<span class="sd">        The `.obsp` key to contain the distance matrix. If `None`, a</span>
<span class="sd">        :class:`~scipy.sparse.csr_matrix` containing the distances is returned.</span>
<span class="sd">    annotation_key</span>
<span class="sd">        The `.obs` key for a categorical annotation to split the data before</span>
<span class="sd">        calculating distances. If `None`, the distances are calculated on the</span>
<span class="sd">        full dataset.</span>
<span class="sd">    annotation_distance</span>
<span class="sd">        Specifies the effect of `annotation_key` in adding a distances</span>
<span class="sd">        between two observations of different type. It can be:</span>
<span class="sd">        </span>
<span class="sd">        - a scalar to use for all annotation pairs</span>
<span class="sd">        - a :class:`~pandas.DataFrame` to give every annotation pair its own</span>
<span class="sd">          finite distance. If some should retain infinite distance, use</span>
<span class="sd">          `np.inf`, `np.nan` or negative values</span>
<span class="sd">        - `None` to use an infinite distance between different annotations</span>
<span class="sd">        - a metric to calculate a distance between the annotation profiles.</span>
<span class="sd">          This is forwarded to :func:`~tacco.utils.cdist` as the `metric`</span>
<span class="sd">          argument, so everything available there is also posible here, e.g.</span>
<span class="sd">          &#39;h2&#39;.</span>
<span class="sd">          </span>
<span class="sd">    distance_scale</span>
<span class="sd">        The distance scale of the relevant local neighbourhoods. If supplied,</span>
<span class="sd">        `annotation_distance` is scaled such that its mean between different</span>
<span class="sd">        types has the same value as this `distance_scale`.</span>
<span class="sd">    annotation_distance_scale</span>
<span class="sd">        A scalar to facilitate conversion between distances in type-space and</span>
<span class="sd">        position-space. This parameter directly specifies the scaling factor of</span>
<span class="sd">        `annotation_distance` and overrides the `distance_scale` setting. If</span>
<span class="sd">        `None`, the bare annotation distances are used. If `None` and</span>
<span class="sd">        `distance_scale` is `None` and `annotation_distance` is a metric</span>
<span class="sd">        specification an exception is raised as position distance and</span>
<span class="sd">        annotation distance cannot be assumed to be comparable.</span>
<span class="sd">    coo_result</span>
<span class="sd">        Whether to return the result as :class:`~scipy.sparse.coo_matrix`</span>
<span class="sd">        instead of a :class:`~scipy.sparse.csr_matrix`. This is faster as it</span>
<span class="sd">        avoids conversion at the end, but if written to an `adata.obsp` key,</span>
<span class="sd">        the `adata` cannot be subsetted anymore... Ignored for dense</span>
<span class="sd">        distances.</span>
<span class="sd">    low_mem</span>
<span class="sd">        Whether to use memory optimization which run longer and may use the</span>
<span class="sd">        harddisc but have the potential to reduce the memory consumption by</span>
<span class="sd">        a factor of 2.</span>
<span class="sd">    verbose</span>
<span class="sd">        Level of verbosity, with `0` (no output), `1` (some output), ...</span>
<span class="sd">    **kw_args</span>
<span class="sd">        Additional keyword arguments are forwarded to on-the-fly distance</span>
<span class="sd">        calculation if necessary. Depending on `max_distance`, this goes to</span>
<span class="sd">        :func:`~tacco.utils.sparse_distance_matrix` or </span>
<span class="sd">        :func:`~tacco.utils.dense_distance_matrix`.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Depending on `result_key` returns either a sparse or dense distance\</span>
<span class="sd">    matrix or an updated input `adata` containing the distance matrix under\</span>
<span class="sd">    `adata.obsp[result_key]`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">base_distance_key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">base_distance_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">:</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">get</span><span class="o">.</span><span class="n">positions</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">position_key</span><span class="p">)</span>

    <span class="n">annotation_column</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">annotation_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">annotation_column</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">annotation_key</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">annotation_column</span><span class="p">,</span> <span class="s1">&#39;cat&#39;</span><span class="p">):</span>
            <span class="n">annotation_column</span> <span class="o">=</span> <span class="n">annotation_column</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">annotation_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">full_data_distance</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation_distance</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">full_data_distance</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">annotation_distance_scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">annotation_distance</span> <span class="o">*</span> <span class="n">annotation_distance_scale</span> <span class="o">&lt;=</span> <span class="n">max_distance</span><span class="p">):</span>
        <span class="n">full_data_distance</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">full_data_distance</span> <span class="o">=</span> <span class="n">full_data_distance</span> <span class="ow">or</span> <span class="n">annotation_column</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="n">full_data_distance</span> <span class="o">=</span> <span class="n">full_data_distance</span> <span class="ow">or</span> <span class="n">base_distance_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    
    <span class="k">def</span> <span class="nf">dense_warning</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">max_distance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;distance_matrix: `max_distance` is `None` which leads to a dense distance matrix being calculated which can be much slower and memory intensive than a sparse version. In case this is intended, one can silence this warning by setting `max_distance` to `np.inf`.&#39;</span><span class="p">)</span>

    <span class="n">tempdir</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">full_data_distance</span><span class="p">:</span>

        <span class="c1"># have to get distances across the full dataset</span>

        <span class="k">if</span> <span class="n">base_distance_key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">base_distance_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_distance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_distance</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">dense_warning</span><span class="p">()</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dense_distance_matrix</span><span class="p">(</span><span class="n">positions</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sparse_distance_matrix</span><span class="p">(</span><span class="n">positions</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">low_mem</span><span class="o">=</span><span class="n">low_mem</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="n">base_distance_key</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="n">base_distance_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_distance_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">coo_result</span><span class="p">:</span> <span class="c1"># cannot implicitly return coo matrix as it collides with adata slicing...</span>
                <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">coo_tocsr_inplace</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="c1"># use inplace operation to reduce memory footprint</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
                
            <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="n">base_distance_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
        
        <span class="k">if</span> <span class="n">annotation_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">annotation_categories</span> <span class="o">=</span> <span class="n">annotation_column</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">annotation_distance</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_number</span><span class="p">(</span><span class="n">annotation_distance</span><span class="p">):</span> <span class="c1"># one distance for all</span>

                <span class="n">annotation_distance</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">annotation_distance</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">annotation_categories</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">annotation_categories</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ac</span> <span class="ow">in</span> <span class="n">annotation_categories</span><span class="p">:</span>
                    <span class="n">annotation_distance</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ac</span><span class="p">,</span><span class="n">ac</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation_distance</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">annotation_distance</span> <span class="o">=</span> <span class="n">annotation_distance</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">annotation_categories</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">annotation_categories</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">distance_scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">annotation_distance_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;`distance_scale` and `annotation_distance_scale` are `None`, but `annotation_distance` is interpreted as the `metric` argument for utils.cdist. In this case it is required to specify a conversion factor between distances in annotation and distances in position using `distance_scale` or `annotation_distance_scale`!&#39;</span><span class="p">)</span>

                <span class="n">average_profiles</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_average_profiles</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">,</span> <span class="n">adata</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">average_profiles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The average profiles from `adata` have length 0! Therefore no meaningful distances between them can be calculated. Either specify the `annotation_distance` by a number or a DataFrame or supply meaningful average profiles, e.g. by setting profiles directly in `adata.var[&quot;</span><span class="si">{</span><span class="n">annotation_key</span><span class="si">}</span><span class="s1">&quot;]` or by supplying expression data in `adata.X`.&#39;</span><span class="p">)</span>
                <span class="n">average_profiles</span> <span class="o">=</span> <span class="n">average_profiles</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">annotation_categories</span><span class="p">)</span>
                
                <span class="n">annotation_distance</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">utils</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">average_profiles</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">average_profiles</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">annotation_distance</span><span class="p">),</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">annotation_categories</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">annotation_categories</span><span class="p">,</span>
                <span class="p">)</span>
                
            <span class="k">if</span> <span class="n">annotation_distance_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">annotation_distance</span> <span class="o">*=</span> <span class="n">annotation_distance_scale</span>
            <span class="k">elif</span> <span class="n">distance_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">conversion_factor</span> <span class="o">=</span> <span class="n">distance_scale</span> <span class="o">/</span> <span class="n">annotation_distance</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">annotation_distance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;annotation_distance_scale from distance_scale </span><span class="si">{</span><span class="n">conversion_factor</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">annotation_distance</span> <span class="o">*=</span> <span class="n">conversion_factor</span>

            <span class="n">annotation_distance</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">annotation_distance</span><span class="p">[</span><span class="n">annotation_distance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">annotation_distance</span> <span class="o">=</span> <span class="n">annotation_distance</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="n">dummies</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">annotation_column</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">distance</span><span class="p">):</span>
                
                <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                
                <span class="c1"># add distances in squares</span>
                <span class="n">distance</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">distance</span><span class="o">.</span><span class="n">data</span>
                <span class="n">annotation_distance</span> <span class="o">*=</span> <span class="n">annotation_distance</span>
                <span class="n">dummies_ad2</span> <span class="o">=</span> <span class="n">dummies</span> <span class="o">@</span> <span class="n">annotation_distance</span>
                <span class="n">utils</span><span class="o">.</span><span class="n">sparse_result_gemmT</span><span class="p">(</span><span class="n">dummies</span><span class="p">,</span> <span class="n">dummies_ad2</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">update_out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># symmetrize result as there can be numerical errors which break the symmetry and lead to very unsymmetric results if rounding error decides over &gt;max_distance and &lt;max_distance</span>

                <span class="n">distance</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

                <span class="n">strip_distance_matrix</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">)</span>
            
            <span class="k">else</span><span class="p">:</span>
                
                <span class="c1"># add distances in squares</span>
                <span class="n">distance</span> <span class="o">*=</span> <span class="n">distance</span>
                <span class="n">annotation_distance</span> <span class="o">*=</span> <span class="n">annotation_distance</span>
                <span class="n">dummies_ad2</span> <span class="o">=</span> <span class="n">dummies</span> <span class="o">@</span> <span class="n">annotation_distance</span>
                <span class="n">distance</span> <span class="o">+=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gemmT</span><span class="p">(</span><span class="n">dummies</span><span class="p">,</span> <span class="n">dummies_ad2</span><span class="p">)</span>

                <span class="n">distance</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># split data and combine all distances</span>

        <span class="n">nobs</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># mapping of index of subset to row number of the whole</span>
        <span class="n">whole_row_dtype</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">min_dtype</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">30</span><span class="p">))</span> <span class="c1"># get smallest possible index dtype - but at least int32, as scipy does not support less..</span>
        <span class="n">whole_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nobs</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">positions</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">whole_row_dtype</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">max_distance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_distance</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            
            <span class="n">dense_warning</span><span class="p">()</span>
            
            <span class="n">distance</span> <span class="o">=</span> <span class="kc">None</span>
            
            <span class="k">for</span> <span class="n">anno</span><span class="p">,</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">annotation_column</span><span class="p">):</span>

                <span class="n">_whole_row</span> <span class="o">=</span> <span class="n">whole_row</span><span class="p">[</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="n">_distance</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dense_distance_matrix</span><span class="p">(</span><span class="n">positions</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">_whole_row</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># now we know the correct datatype:</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nobs</span><span class="p">,</span><span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_distance</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                
                <span class="n">_update_submatrix</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">_distance</span><span class="p">,</span> <span class="n">_whole_row</span><span class="p">,</span> <span class="n">_whole_row</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            
            <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">col</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                <span class="n">tempdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;temp_distance_matrix_&#39;</span><span class="p">,</span><span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
                <span class="n">buffer_directory</span> <span class="o">=</span> <span class="n">tempdir</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">buffer_directory</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">try</span><span class="p">:</span>

                <span class="k">for</span> <span class="n">anno</span><span class="p">,</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">annotation_column</span><span class="p">):</span>

                    <span class="n">_whole_row</span> <span class="o">=</span> <span class="n">whole_row</span><span class="p">[</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

                    <span class="n">_distance</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sparse_distance_matrix</span><span class="p">(</span><span class="n">positions</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">_whole_row</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">low_mem</span><span class="o">=</span><span class="n">low_mem</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">_distance</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">buffer_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_whole_row</span><span class="p">[</span><span class="n">_distance</span><span class="o">.</span><span class="n">row</span><span class="p">])</span>
                            <span class="n">col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_whole_row</span><span class="p">[</span><span class="n">_distance</span><span class="o">.</span><span class="n">col</span><span class="p">])</span>
                            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_distance</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;row.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                                <span class="n">_whole_row</span><span class="p">[</span><span class="n">_distance</span><span class="o">.</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;col.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                                <span class="n">_whole_row</span><span class="p">[</span><span class="n">_distance</span><span class="o">.</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;data.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                                <span class="n">_distance</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_distance</span><span class="p">)</span>

                <span class="c1"># cleanup data as soon as we dont need it anymore</span>
                <span class="n">distance_dtype</span> <span class="o">=</span> <span class="n">_distance</span><span class="o">.</span><span class="n">dtype</span>
                <span class="k">del</span> <span class="n">_distance</span>
                <span class="k">del</span> <span class="n">whole_row</span>

                <span class="n">distance</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">nobs</span><span class="p">,</span><span class="n">nobs</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">buffer_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">distance</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                    <span class="n">distance</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                    <span class="n">distance</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">distance</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;row.bin&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">whole_row_dtype</span><span class="p">)</span>
                    <span class="n">distance</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;col.bin&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">whole_row_dtype</span><span class="p">)</span>
                    <span class="n">distance</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;data.bin&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">distance_dtype</span><span class="p">)</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
                    <span class="n">tempdir</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
                <span class="k">raise</span>
                
    <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">coo_result</span><span class="p">:</span> <span class="c1"># cannot implicitly return coo matrix as it collides with adata slicing...</span>
        <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
            <span class="n">buffer_directory</span> <span class="o">=</span> <span class="n">tempdir</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="k">if</span> <span class="n">tempdir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">coo_tocsr_buffered</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">buffer_directory</span><span class="o">=</span><span class="n">buffer_directory</span><span class="p">)</span> <span class="c1"># use buffered operation to reduce memory footprint</span>
            <span class="k">if</span> <span class="n">tempdir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tempdir</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">result_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">distance</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="n">result_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="k">return</span> <span class="n">adata</span></div>


<div class="viewcode-block" id="affinity">
<a class="viewcode-back" href="../../../_autosummary/tacco.tools.affinity.html#tacco.tools.affinity">[docs]</a>
<span class="k">def</span> <span class="nf">affinity</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">,</span>
    <span class="n">distance_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">result_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Calculates an affinity from a distance matrix.</span>

<span class="sd">    The affinity is calculated according to</span>

<span class="sd">        `aff(i,j) = exp(-dist(i,j)**2 / (2 * sigma**2))`</span>

<span class="sd">    where sigma gives the half width of the Gaussian weight. This can be used</span>
<span class="sd">    e.g. for spectral clustering.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata</span>
<span class="sd">        A :class:`~anndata.AnnData` with distance under `.obsp[distance_key]`</span>
<span class="sd">        or a (sparse) distance matrix.</span>
<span class="sd">    sigma</span>
<span class="sd">        The width parameter of the Gaussian.</span>
<span class="sd">    distance_key</span>
<span class="sd">        The `.obsp` key with the distances. Ignored if `adata` is the distance</span>
<span class="sd">        matrix.</span>
<span class="sd">    result_key</span>
<span class="sd">        The `.obsp` key to contain the affinities. If `None`, a</span>
<span class="sd">        :class:`~scipy.sparse.csr_matrix` containing the affinities is</span>
<span class="sd">        returned. Ignored if `adata` is the distance matrix.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Depending on `result_key` returns either the (sparse) affinity matrix or an\</span>
<span class="sd">    updated input `adata` contining the affinity matrix under\</span>
<span class="sd">    `adata.obsp[result_key]`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">distance_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`affinity_key` is required if `adata` is an `AnnData`!&#39;</span><span class="p">)</span>
        <span class="n">affinity</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="n">distance_key</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affinity</span> <span class="o">=</span> <span class="n">adata</span>
        <span class="n">result_key</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># the results are returned directly</span>

    <span class="k">if</span> <span class="n">result_key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result_key</span> <span class="o">!=</span> <span class="n">distance_key</span><span class="p">:</span>
        <span class="n">affinity</span> <span class="o">=</span> <span class="n">affinity</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">affinity</span><span class="p">):</span>
        <span class="n">affinity</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">affinity</span><span class="o">.</span><span class="n">data</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affinity</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">affinity</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">result_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">affinity</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="n">result_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">affinity</span>
        <span class="k">return</span> <span class="n">adata</span></div>


<span class="k">def</span> <span class="nf">sparse_dummies</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="n">series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="s1">&#39;cat&#39;</span><span class="p">):</span>
        <span class="n">series</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
    
    <span class="n">dummies</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="n">dummies</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">min_dtype</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)))</span>
    <span class="n">dummies</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>
    <span class="n">dummies</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">dummies</span><span class="p">,</span> <span class="n">series</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span>

<div class="viewcode-block" id="spectral_clustering">
<a class="viewcode-back" href="../../../_autosummary/tacco.tools.spectral_clustering.html#tacco.tools.spectral_clustering">[docs]</a>
<span class="k">def</span> <span class="nf">spectral_clustering</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span>
    <span class="n">max_size</span><span class="p">,</span>
    <span class="n">min_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">affinity_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">result_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cut_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
    <span class="n">position_key</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">],</span>
    <span class="n">position_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">position_range</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">max_aspect_ratio</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Performs spectral clustering on an affinity matrix.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata</span>
<span class="sd">        A :class:`~anndata.AnnData` with affinity under `.obsp[affinity_key]`</span>
<span class="sd">        or a (sparse) affinity matrix.</span>
<span class="sd">    max_size</span>
<span class="sd">        The clustering goes on until no cluster has more elements than this.</span>
<span class="sd">    min_size</span>
<span class="sd">        The clustering does not subcluster clusters smaller than this number.</span>
<span class="sd">        If `None`, uses `max_size/5`</span>
<span class="sd">    affinity_key</span>
<span class="sd">        The `.obsp` key with the affinities. Ignored if `adata` is the affinity</span>
<span class="sd">        matrix.</span>
<span class="sd">    result_key</span>
<span class="sd">        The `.obs` key to contain the clusters. If `None`, a</span>
<span class="sd">        :class:`~pandas.Series` containing the cluster labels is returned.</span>
<span class="sd">        Ignored if `adata` is the affinity matrix.</span>
<span class="sd">    dim</span>
<span class="sd">        The dimensionality of the manifold. If `None`, it is taken from</span>
<span class="sd">        supplied position space coordinates (if available) or being inferred on</span>
<span class="sd">        the fly. The `dim` is used to decide whether to subcluster a given</span>
<span class="sd">        cluster based on the surface to volume ratio.</span>
<span class="sd">    cut_threshold</span>
<span class="sd">        For every proposed subclustering a certain amount of affinity has to be</span>
<span class="sd">        cut. This number scales the decision threshold: higher values mean more</span>
<span class="sd">        cuts, lower values mean less cuts. The threshold itself scales also</span>
<span class="sd">        with the `(1/dim)`-th root of the cluster size.</span>
<span class="sd">    position_key</span>
<span class="sd">        The `.obsm` key or array-like of `.obs` keys with the position space</span>
<span class="sd">        coordinates. This is used to efficiently get small subproblems by</span>
<span class="sd">        spatial binning. If `position_key` or `position_scale` is `None`, do</span>
<span class="sd">        hirarchical clustering to iteratively split the problems in smaller</span>
<span class="sd">        subproblems. Ignored if `adata` is the affinity matrix.</span>
<span class="sd">    position_scale</span>
<span class="sd">        The expected feature size to use for splitting the problem spatially.</span>
<span class="sd">        If `position_key` or `position_scale` is `None`, do hirarchical</span>
<span class="sd">        clustering to iteratively split the problems in smaller subproblems.</span>
<span class="sd">        Ignored if `adata` is the affinity matrix.</span>
<span class="sd">    position_range</span>
<span class="sd">        A cluster is subclustered when it has a spatial size (defined as twice</span>
<span class="sd">        the standard deviation in the largest spatial PCA direction) of more</span>
<span class="sd">        than `position_scale*position_range*` and it is not subclustered if its</span>
<span class="sd">        spatial size is smaller than `position_scale/position_range`. Ignored</span>
<span class="sd">        if `adata` is the affinity matrix.</span>
<span class="sd">    max_aspect_ratio</span>
<span class="sd">        A cluster is subclustered when it has a larger aspect ratio (defined as</span>
<span class="sd">        the ratio of the standard deviations in the largest and smallest</span>
<span class="sd">        spatial PCA direction) of more than `max_aspect_ratio`. Ignored if</span>
<span class="sd">        `adata` is the affinity matrix.</span>
<span class="sd">    verbose</span>
<span class="sd">        Level of verbosity, with `0` (no output), `1` (some output), ...</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Depending on `result_key` returns either a :class:`~pandas.Series` with\</span>
<span class="sd">    the cluster labels or an updated input `adata` contining the cluster\</span>
<span class="sd">    labels under `adata.obs[result_key]`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">max_size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`max_size` is 1 (or less), which does not make sense for clustering!&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">min_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_size</span> <span class="o">=</span> <span class="n">max_size</span> <span class="o">/</span> <span class="mi">5</span>
    <span class="k">if</span> <span class="n">min_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">min_size</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">affinity_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`affinity_key` is required if `adata` is an `anndata.AnnData`!&#39;</span><span class="p">)</span>
        <span class="n">affinity</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="n">affinity_key</span><span class="p">]</span>
        <span class="n">obs_index</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affinity</span> <span class="o">=</span> <span class="n">adata</span>
        <span class="n">result_key</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># the results are returned directly</span>
        <span class="n">obs_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">affinity</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">affinity</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affinity</span><span class="p">,</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">,</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">)):</span>
        <span class="n">affinity</span> <span class="o">=</span> <span class="n">affinity</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="c1"># spectral clustering wants high precision</span>
    <span class="n">affinity</span> <span class="o">=</span> <span class="n">affinity</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="c1"># spectral clustering wants high precision</span>
    
    <span class="k">if</span> <span class="n">position_key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">):</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">get</span><span class="o">.</span><span class="n">positions</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">position_key</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># get dimensionality if possible</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># otherwise prepare to estimate it</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dim_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dim_data</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">position_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># do not use positions, if it is not specified how.</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">n_components</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">csgraph</span><span class="o">=</span><span class="n">affinity</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">new_components</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">obs_index</span><span class="p">)</span>

    <span class="n">max_n_clusters_per_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">min_n_clusters_per_level</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">perform_clustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">affinity</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">affinity</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n_clusters</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)</span>
        <span class="n">n_unique_labels</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span>
        <span class="k">while</span> <span class="n">n_unique_labels</span> <span class="o">!=</span> <span class="n">n_clusters</span><span class="p">:</span> <span class="c1"># This should loop only once. But in rare cases it does that multiple times: https://github.com/scikit-learn/scikit-learn/issues/18083</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">SpectralClustering</span><span class="p">(</span>
                <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span>
                <span class="n">affinity</span><span class="o">=</span><span class="s1">&#39;precomputed&#39;</span><span class="p">,</span>
                <span class="n">assign_labels</span><span class="o">=</span><span class="s2">&quot;discretize&quot;</span><span class="p">,</span>
                <span class="n">eigen_solver</span><span class="o">=</span><span class="s2">&quot;amg&quot;</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
            <span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">affinity</span><span class="p">)</span><span class="o">.</span><span class="n">labels_</span>
            <span class="n">random_state</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">n_unique_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">labels</span>

    <span class="c1"># handle (possibly many) small components right away</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">new_components</span>
    <span class="n">components_sizes</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
    <span class="n">components_sizes</span> <span class="o">=</span> <span class="n">components_sizes</span><span class="p">[</span><span class="n">components_sizes</span> <span class="o">&lt;=</span> <span class="n">min_size</span><span class="p">]</span>
    <span class="n">component_cluster</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">components_sizes</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>
    <span class="n">cluster</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">obs_index</span><span class="p">)</span>
    <span class="n">cluster</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">component_cluster</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">component_cluster</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_cluster</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cluster_i</span> <span class="o">=</span> <span class="n">component_cluster</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cluster_i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">new_components</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">component_cluster</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">last_remaining_points</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">last_remaining_clusters</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">last_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># iterate until there are no new components left</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">new_components</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">new_components</span>

        <span class="n">components_sizes</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>

        <span class="n">remaining_points</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">components</span><span class="o">.</span><span class="n">isna</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">remaining_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">components_sizes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">counter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;new component round with </span><span class="si">{</span><span class="n">remaining_points</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">remaining_points</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s1">%) remaining points in </span><span class="si">{</span><span class="n">remaining_clusters</span><span class="si">}</span><span class="s1"> clusters of mean size </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">components_sizes</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">last_message</span> <span class="o">=</span> <span class="s1">&#39;comp&#39;</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">last_remaining_points</span> <span class="o">==</span> <span class="n">remaining_points</span> <span class="ow">and</span> <span class="n">last_remaining_clusters</span> <span class="o">==</span> <span class="n">remaining_clusters</span> <span class="ow">and</span> <span class="n">last_dim</span> <span class="o">==</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The hirarchical clustering is caught in a loop without progress...&#39;</span><span class="p">)</span>
        <span class="n">last_remaining_points</span> <span class="o">=</span> <span class="n">remaining_points</span>
        <span class="n">last_remaining_clusters</span> <span class="o">=</span> <span class="n">remaining_clusters</span>
        <span class="n">last_dim</span> <span class="o">=</span> <span class="n">dim</span>
        
        <span class="n">surface_criterion_stats</span> <span class="o">=</span> <span class="p">{</span><span class="kc">True</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="kc">False</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
        <span class="n">position_criterion_stats</span> <span class="o">=</span> <span class="p">{</span><span class="kc">True</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="kc">False</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>

        <span class="n">new_components</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">components</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">new_component_i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">last_message</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">c_size</span> <span class="ow">in</span> <span class="n">components_sizes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">_selection</span> <span class="o">=</span> <span class="n">components</span><span class="o">==</span><span class="n">c</span>
            <span class="n">aff</span> <span class="o">=</span> <span class="n">affinity</span><span class="p">[</span><span class="n">_selection</span><span class="p">][:,</span><span class="n">_selection</span><span class="p">]</span>

            <span class="c1"># Sometimes there are disconnected components in a single &quot;component&quot;... Probably due to an instability in the clustering.</span>
            <span class="n">n_components</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">csgraph</span><span class="o">=</span><span class="n">aff</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">last_message</span> <span class="o">==</span> <span class="s1">&#39;disco&#39;</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">c_size</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">splitting disconnected component of size </span><span class="si">{</span><span class="n">c_size</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="n">last_message</span> <span class="o">=</span> <span class="s1">&#39;disco&#39;</span>

                <span class="n">labels</span> <span class="o">+=</span> <span class="n">new_component_i</span>
                <span class="n">new_components</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">_selection</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()]</span> <span class="o">=</span> <span class="n">labels</span>
                <span class="n">new_component_i</span> <span class="o">+=</span> <span class="n">n_components</span>
                <span class="k">continue</span>

            <span class="n">approximate_cluster_number</span> <span class="o">=</span> <span class="n">c_size</span> <span class="o">/</span> <span class="n">max_size</span>
            
            <span class="c1"># check whether this cluster should be subclustered</span>
            <span class="n">subclustering</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># `None` means undecided</span>
            <span class="k">if</span> <span class="n">c_size</span> <span class="o">&lt;=</span> <span class="n">min_size</span><span class="p">:</span>
                <span class="n">subclustering</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">c_size</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="n">subclustering</span> <span class="o">=</span> <span class="kc">True</span>
                
            <span class="k">if</span> <span class="n">subclustering</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_positions</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">_selection</span><span class="p">]</span>
                <span class="n">_X</span> <span class="o">=</span> <span class="n">_positions</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_positions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">_X</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">_X</span> <span class="o">=</span> <span class="n">_X</span><span class="o">.</span><span class="n">A</span>
                <span class="n">_sizes</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">_X</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">_sizes</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c_size</span><span class="p">)</span> <span class="c1"># these are now twice the standard deviation, i.e. some kind of diameter</span>
                <span class="n">_sizes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1"># sorts ascending</span>
                <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">_largest_size</span> <span class="o">=</span> <span class="n">_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">_largest_size</span> <span class="o">&gt;</span> <span class="n">position_scale</span> <span class="o">*</span> <span class="n">position_range</span><span class="p">:</span>
                    <span class="n">subclustering</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">_largest_size</span> <span class="o">&lt;</span> <span class="n">position_scale</span> <span class="o">/</span> <span class="n">position_range</span><span class="p">:</span>
                    <span class="n">subclustering</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="n">aspect_ratio</span> <span class="o">&gt;</span> <span class="n">max_aspect_ratio</span><span class="p">:</span>
                    <span class="n">subclustering</span> <span class="o">=</span> <span class="kc">True</span>
                
                <span class="n">position_criterion_stats</span><span class="p">[</span><span class="n">subclustering</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">position criteria&#39;</span><span class="p">,</span><span class="n">_largest_size</span><span class="p">,</span><span class="n">aspect_ratio</span><span class="p">,</span> <span class="n">subclustering</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="n">last_message</span> <span class="o">=</span> <span class="s1">&#39;pos&#39;</span>
                
            <span class="k">if</span> <span class="n">subclustering</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># This is already a good cluster</span>

                <span class="n">cluster</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">_selection</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()]</span> <span class="o">=</span> <span class="n">cluster_i</span>
                <span class="n">cluster_i</span> <span class="o">+=</span> <span class="mi">1</span>
                
            <span class="k">elif</span> <span class="n">subclustering</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># We need an estimate of the dimension before we go on with this size cluster, save that for later</span>

                <span class="n">new_components</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">_selection</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()]</span> <span class="o">=</span> <span class="n">new_component_i</span>
                <span class="n">new_component_i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Continue subclustering</span>
                
                <span class="n">positon_splitted</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    
                    <span class="n">_positions</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">_selection</span><span class="p">]</span>
                    
                    <span class="c1"># find the direction with the biggest extent</span>
                    <span class="n">maxs</span><span class="p">,</span> <span class="n">mins</span> <span class="o">=</span> <span class="n">_positions</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">_positions</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">extents</span> <span class="o">=</span> <span class="n">maxs</span> <span class="o">-</span> <span class="n">mins</span>
                    <span class="n">dmax</span> <span class="o">=</span> <span class="n">extents</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
                    <span class="n">extent</span> <span class="o">=</span> <span class="n">extents</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">dmax</span><span class="p">]</span>
                    <span class="n">_min</span> <span class="o">=</span> <span class="n">mins</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">dmax</span><span class="p">]</span>
                    <span class="n">_max</span> <span class="o">=</span> <span class="n">maxs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">dmax</span><span class="p">]</span>

                    <span class="n">boundary_layer_width</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">position_scale</span>
                    <span class="k">if</span> <span class="n">extent</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">boundary_layer_width</span><span class="p">:</span> <span class="c1"># otherwise it makes not much sense</span>

                        <span class="n">coords</span> <span class="o">=</span> <span class="n">_positions</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="n">dmax</span><span class="p">]</span>

                        <span class="n">mid</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">_max</span> <span class="o">+</span> <span class="n">_min</span><span class="p">)</span>

                        <span class="n">left_mid_right</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="n">_min</span><span class="p">,</span><span class="n">mid</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">boundary_layer_width</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">boundary_layer_width</span><span class="p">,</span><span class="n">_max</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="s1">&#39;mid&#39;</span><span class="p">,</span><span class="s1">&#39;right&#39;</span><span class="p">])</span>
                        <span class="n">vc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">left_mid_right</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>

                        <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                        <span class="n">merged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">min_dtype</span><span class="p">(</span><span class="n">n_points</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>
                        <span class="n">merged</span><span class="p">[</span><span class="n">left_mid_right</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_points</span>
                        <span class="n">merged</span><span class="p">[</span><span class="n">left_mid_right</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_points</span><span class="o">+</span><span class="mi">1</span>

                        <span class="n">dummies</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">sparse_dummies</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                        <span class="n">dummies</span> <span class="o">=</span> <span class="n">dummies</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                        <span class="n">d_aff</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">gemmT</span><span class="p">(</span><span class="n">dummies</span><span class="p">,</span> <span class="n">aff</span><span class="p">,</span> <span class="n">sparse_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">d_aff_d</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">gemmT</span><span class="p">(</span><span class="n">d_aff</span><span class="p">,</span> <span class="n">dummies</span><span class="p">,</span> <span class="n">sparse_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                        <span class="c1"># allow for extra clusters in the boundary layer for two reasons:</span>
                        <span class="c1"># - it is set up already, so additional custers should be relatively cheap</span>
                        <span class="c1"># - often the boundary layer contains loosely coupled clusters, which makes it less likey to succed with the split into two big chunks</span>
                        <span class="n">sol_n_clusters</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_n_clusters_per_level</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">vc</span><span class="p">[</span><span class="s1">&#39;mid&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">max_size</span><span class="p">),</span> <span class="n">c_size</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">last_message</span> <span class="o">==</span> <span class="s1">&#39;spatial&#39;</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="n">c_size</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">spatial split of component of size </span><span class="si">{</span><span class="n">c_size</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                            <span class="n">last_message</span> <span class="o">=</span> <span class="s1">&#39;spatial&#39;</span>
                        
                        <span class="n">split</span> <span class="o">=</span> <span class="n">perform_clustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">sol_n_clusters</span><span class="p">,</span><span class="n">affinity</span><span class="o">=</span><span class="n">d_aff_d</span><span class="p">)</span>

                        <span class="n">labels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">split</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">cats</span><span class="p">)[</span><span class="n">merged</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                        
                        <span class="n">positon_splitted</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">positon_splitted</span><span class="p">:</span>

                    <span class="n">sol_n_clusters</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_n_clusters_per_level</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">approximate_cluster_number</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span> <span class="n">c_size</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">last_message</span> <span class="o">==</span> <span class="s1">&#39;reclustering&#39;</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="n">c_size</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">reclustering of component of size </span><span class="si">{</span><span class="n">c_size</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                        <span class="n">last_message</span> <span class="o">=</span> <span class="s1">&#39;reclustering&#39;</span>
                    
                    <span class="n">labels</span> <span class="o">=</span> <span class="n">perform_clustering</span><span class="p">(</span><span class="n">sol_n_clusters</span><span class="p">,</span> <span class="n">aff</span><span class="p">)</span>
                
                <span class="c1"># get data about the proposed split</span>
                <span class="n">pre_sum</span> <span class="o">=</span> <span class="n">aff</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">pre_sum</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Got cluster without connectons! Something must be wrong with the supplied affinity!&#39;</span><span class="p">)</span>
                <span class="n">post_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">_sel</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">l</span>
                    <span class="n">_aff</span> <span class="o">=</span> <span class="n">aff</span><span class="p">[</span><span class="n">_sel</span><span class="p">][:,</span><span class="n">_sel</span><span class="p">]</span>
                    <span class="n">post_sum</span> <span class="o">+=</span> <span class="n">_aff</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">pre_sum</span> <span class="o">-</span> <span class="n">post_sum</span>
                
                <span class="k">if</span> <span class="n">dim_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dim_data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">counter</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">pre_sum</span><span class="p">,</span><span class="n">c_size</span><span class="p">))</span>
                
                <span class="k">if</span> <span class="n">subclustering</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># if still undecided</span>
                    <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">rdelta</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">/</span> <span class="n">pre_sum</span> <span class="c1"># (cut affinity)/affinity</span>
                        <span class="c1"># (cut affinity)/affinity for a cut through a c_size=N**(dim-1)*N cartesian hyperblock with nearest neighbour affinity of 1:</span>
                        <span class="c1"># affinity for a N**dim cube: Ac = dim*(N-1)*N**(dim-1)</span>
                        <span class="c1"># affinity for a N**(dim-1)*N block: Ab = 2*Ac + N**(dim-1)</span>
                        <span class="c1"># (cut affinity)/affinity = 1 / (1 + 2 * dim * (N - 1))</span>
                        <span class="n">cdelta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dim</span> <span class="o">*</span> <span class="p">((</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">c_size</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">dim</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="n">sdelta</span> <span class="o">=</span> <span class="n">rdelta</span> <span class="o">/</span> <span class="n">cdelta</span>
                        <span class="k">if</span> <span class="n">sdelta</span> <span class="o">&gt;</span> <span class="n">cut_threshold</span><span class="p">:</span>
                            <span class="n">subclustering</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">subclustering</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">surface_criterion_stats</span><span class="p">[</span><span class="n">subclustering</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">surface criteria&#39;</span><span class="p">,</span><span class="n">sdelta</span><span class="p">,</span> <span class="n">subclustering</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                            <span class="n">last_message</span> <span class="o">=</span> <span class="s1">&#39;surf&#39;</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1"># if we have no idea about the dimension we just go on subclustering...</span>
                        <span class="n">subclustering</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">subclustering</span><span class="p">:</span>
                    <span class="c1"># accept the new clusters</span>
                    <span class="n">labels</span> <span class="o">+=</span> <span class="n">new_component_i</span>
                    <span class="n">new_components</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">_selection</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()]</span> <span class="o">=</span> <span class="n">labels</span>
                    <span class="n">new_component_i</span> <span class="o">+=</span> <span class="n">sol_n_clusters</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># reject the new clusters and add the current cluster to the finished clusters</span>
                    <span class="n">cluster</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">_selection</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()]</span> <span class="o">=</span> <span class="n">cluster_i</span>
                    <span class="n">cluster_i</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">surface_criterion_stats</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">surface criteria stats: </span><span class="si">{</span><span class="n">surface_criterion_stats</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">surface_criterion_stats</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">surface_criterion_stats</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">surface_criterion_stats</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s1">% have been splitted&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">position_criterion_stats</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">position criteria stats: </span><span class="si">{</span><span class="n">position_criterion_stats</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">position_criterion_stats</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">position_criterion_stats</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">position_criterion_stats</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s1">% have been splitted&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">last_message</span> <span class="o">=</span> <span class="s1">&#39;stats&#39;</span>
        
        <span class="k">if</span> <span class="n">dim_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">enough_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">50</span>
            <span class="n">need_dim_urgently</span> <span class="o">=</span> <span class="n">components_sizes</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">max_size</span>
            <span class="k">if</span> <span class="n">enough_data</span> <span class="ow">or</span> <span class="n">need_dim_urgently</span><span class="p">:</span> <span class="c1"># only dare to estimate the dimension if some data is available.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">enough_data</span> <span class="ow">and</span> <span class="n">need_dim_urgently</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">not enough_data and need_dim_urgently&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                        <span class="n">last_message</span> <span class="o">=</span> <span class="s1">&#39;dimension&#39;</span>

                <span class="n">dimdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dim_data</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;round&#39;</span><span class="p">,</span><span class="s1">&#39;delta&#39;</span><span class="p">,</span><span class="s1">&#39;sigma&#39;</span><span class="p">,</span><span class="s1">&#39;N&#39;</span><span class="p">])</span>
                <span class="c1"># calculate the effecive dimension for every recorded cut from the scaling of surface VS volume terms</span>
                <span class="n">dimdf</span><span class="p">[</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dimdf</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dimdf</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">dimdf</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">])</span>

                <span class="c1"># fit the effective dimension in windows of log(cluster_size) and report the intercept:</span>
                <span class="c1"># Small clusters are cut hard through the volume instead of at loose connections of subclusters</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># half window size</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dimdf</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">dimdf</span><span class="p">[</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="n">fits</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">]</span> <span class="c1"># better than nothing... and stabilizes the estimate.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">dr</span><span class="p">,</span><span class="n">q</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span><span class="o">-</span><span class="mf">0.1</span><span class="p">):</span>
                        <span class="n">sub</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">+</span><span class="n">dr</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">q</span><span class="o">&gt;</span><span class="n">r</span><span class="o">-</span><span class="n">dr</span><span class="p">)</span>
                        <span class="n">X</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span>
                            <span class="n">_dim</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">linear_model</span><span class="o">.</span><span class="n">LinearRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">intercept_</span>
                            <span class="n">fits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_dim</span><span class="p">)</span>

                <span class="c1"># final dimension is the average of all these intercepts:</span>
                <span class="c1"># There is some systematic variation in the result wrt the cluster size e.g. as small clusters show e.g. noise and 3D structure while larger clusters reveal properties of the effective manifold but have less measurements and more cuts through loose connections.</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fits</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">estimated dimension is </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1"> ; len(fits)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fits</span><span class="p">)</span><span class="si">}</span><span class="s1"> ; len(dim_data)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dim_data</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="n">last_message</span> <span class="o">=</span> <span class="s1">&#39;dimension&#39;</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">()</span>
    
    <span class="c1"># normalize the cluster numbers such that the n-th occuring cluster has number n</span>
    <span class="n">cluster</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
    <span class="n">cluster</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">)),</span><span class="n">index</span><span class="o">=</span><span class="n">cluster</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="o">.</span><span class="n">unique</span><span class="p">())[</span><span class="n">cluster</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">cluster</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">obs_index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">result_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cluster</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">result_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster</span>
        <span class="k">return</span> <span class="n">adata</span></div>


<span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_distribute_molecules_sparse</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">X_indptr</span><span class="p">,</span> <span class="n">X_indices</span><span class="p">,</span> <span class="n">X_data</span><span class="p">,</span> <span class="n">genes</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_obs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_indptr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    
    <span class="n">mol</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_obs</span><span class="p">):</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">obs</span><span class="p">]</span>
        <span class="n">ptr0</span> <span class="o">=</span> <span class="n">X_indptr</span><span class="p">[</span><span class="n">obs</span><span class="p">]</span>
        <span class="n">ptr1</span> <span class="o">=</span> <span class="n">X_indptr</span><span class="p">[</span><span class="n">obs</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">X_indices</span><span class="p">[</span><span class="n">ptr0</span><span class="p">:</span><span class="n">ptr1</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">X_data</span><span class="p">[</span><span class="n">ptr0</span><span class="p">:</span><span class="n">ptr1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
            <span class="n">gene</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">genes</span><span class="p">[</span><span class="n">mol</span><span class="p">:(</span><span class="n">mol</span><span class="o">+</span><span class="n">count</span><span class="p">)]</span> <span class="o">=</span> <span class="n">gene</span>
            <span class="n">index</span><span class="p">[</span><span class="n">mol</span><span class="p">:(</span><span class="n">mol</span><span class="o">+</span><span class="n">count</span><span class="p">)]</span> <span class="o">=</span> <span class="n">obs</span>
            <span class="n">positions</span><span class="p">[</span><span class="n">mol</span><span class="p">:(</span><span class="n">mol</span><span class="o">+</span><span class="n">count</span><span class="p">)]</span> <span class="o">=</span> <span class="n">center</span>
            <span class="n">mol</span> <span class="o">+=</span> <span class="n">count</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_distribute_molecules_dense</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">genes</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_obs</span><span class="p">,</span> <span class="n">n_gene</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="n">mol</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_obs</span><span class="p">):</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">obs</span><span class="p">]</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">obs</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_gene</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">gene</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">genes</span><span class="p">[</span><span class="n">mol</span><span class="p">:(</span><span class="n">mol</span><span class="o">+</span><span class="n">count</span><span class="p">)]</span> <span class="o">=</span> <span class="n">gene</span>
                <span class="n">index</span><span class="p">[</span><span class="n">mol</span><span class="p">:(</span><span class="n">mol</span><span class="o">+</span><span class="n">count</span><span class="p">)]</span> <span class="o">=</span> <span class="n">obs</span>
                <span class="n">positions</span><span class="p">[</span><span class="n">mol</span><span class="p">:(</span><span class="n">mol</span><span class="o">+</span><span class="n">count</span><span class="p">)]</span> <span class="o">=</span> <span class="n">center</span>
                <span class="n">mol</span> <span class="o">+=</span> <span class="n">count</span>

<div class="viewcode-block" id="distribute_molecules">
<a class="viewcode-back" href="../../../_autosummary/tacco.tools.distribute_molecules.html#tacco.tools.distribute_molecules">[docs]</a>
<span class="k">def</span> <span class="nf">distribute_molecules</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span>
    <span class="n">width</span><span class="p">,</span>
    <span class="n">position_key</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">),</span>
    <span class="n">obs_index_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">var_index_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Distributes the counts of observations randomly in space.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata</span>
<span class="sd">        An :class:`~anndata.AnnData` with counts in `.X`.</span>
<span class="sd">    width</span>
<span class="sd">        The width of the Gaussian to use for randomly placing molecules around</span>
<span class="sd">        the central position.</span>
<span class="sd">    position_key</span>
<span class="sd">        The `.obsm` key or a tuple of `.obs` keys with the position space</span>
<span class="sd">        coordinates.</span>
<span class="sd">    obs_index_key</span>
<span class="sd">        A string specifying the name of the column to write the old</span>
<span class="sd">        `.obs.index` (i.e. the cell names) to. If `None`, tries to guess a</span>
<span class="sd">        reasonable name.</span>
<span class="sd">    var_index_key</span>
<span class="sd">        A string specifying the name of the column to write the old</span>
<span class="sd">        `.var.index` (i.e. the gene names) to. If `None`, tries to guess a</span>
<span class="sd">        reasonable name.</span>
<span class="sd">    verbose</span>
<span class="sd">        Level of verbosity, with `0` (no output), `1` (some output), ...</span>
<span class="sd">    seed</span>
<span class="sd">        The seed for the randomness.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A :class:`~pandas.DataFrame` with a single molecule per row and with\</span>
<span class="sd">    scattered position space coordinates.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">obs_index_key</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">guess_obs_index_key</span><span class="p">(</span><span class="n">obs_index_key</span><span class="p">,</span> <span class="n">adata</span><span class="p">)</span>
    <span class="n">var_index_key</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">guess_var_index_key</span><span class="p">(</span><span class="n">var_index_key</span><span class="p">,</span> <span class="n">adata</span><span class="p">)</span>
    
    <span class="n">preprocessing</span><span class="o">.</span><span class="n">check_counts_validity</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
    
    <span class="n">coords</span> <span class="o">=</span> <span class="n">get</span><span class="o">.</span><span class="n">positions</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">position_key</span><span class="p">)</span>
    <span class="n">coords_names</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">n_obs</span><span class="p">,</span> <span class="n">n_gene</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="n">n_mol</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    
    <span class="n">pos_dtype</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">geneid_dtype</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">min_dtype</span><span class="p">(</span><span class="n">n_gene</span><span class="p">)</span>
    <span class="n">obsid_dtype</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">min_dtype</span><span class="p">(</span><span class="n">n_obs</span><span class="p">)</span>
    
    <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_mol</span><span class="p">,</span><span class="n">n_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pos_dtype</span><span class="p">)</span>
    <span class="n">genes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_mol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">geneid_dtype</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_mol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">obsid_dtype</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;`adata.X` is a sparse matrix but not in csr format, and has to be converted first which takes time. To avoid that convert it before.&#39;</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="n">_distribute_molecules_sparse</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">genes</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span>
        <span class="n">_distribute_molecules_dense</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">genes</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>
    
    <span class="n">random_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="k">if</span> <span class="n">positions</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">random_dtype</span><span class="p">)</span>
    
    <span class="n">molecules</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">coords_names</span><span class="p">)</span>
    <span class="n">cat_var_index</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
    <span class="n">cat_obs_index</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
    <span class="n">molecules</span><span class="p">[</span><span class="n">var_index_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat_var_index</span><span class="p">[</span><span class="n">genes</span><span class="p">]</span>
    <span class="n">molecules</span><span class="p">[</span><span class="n">obs_index_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat_obs_index</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">molecules</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Broad Institute.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>