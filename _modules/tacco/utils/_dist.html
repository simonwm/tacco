<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tacco.utils._dist &mdash; TACCO  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=ad0ac74c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/readthedocs-custom.css?v=c8300288" />
      <link rel="stylesheet" type="text/css" href="../../../_static/notebook_hacks.css?v=e4ce2130" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html">
            
              <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/tacco.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">TACCO</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tacco.utils._dist</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tacco.utils._dist</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">issparse</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_math</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_utils</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">prange</span>
<span class="kn">import</span> <span class="nn">numba</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">threadpoolctl</span> <span class="kn">import</span> <span class="n">threadpool_limits</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<div class="viewcode-block" id="min_dtype">
<a class="viewcode-back" href="../../../_autosummary/tacco.utils.min_dtype.html#tacco.utils.min_dtype">[docs]</a>
<span class="k">def</span> <span class="nf">min_dtype</span><span class="p">(</span>
    <span class="n">maximum</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Gives the smallest signed integer dtype which is necessary to represent</span>
<span class="sd">    `maximum`.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    maximum</span>
<span class="sd">        The integer to be representable in the dtype.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A signed integer dtype.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">maximum</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">7</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span>
    <span class="k">elif</span> <span class="n">maximum</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">15</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span>
    <span class="k">elif</span> <span class="n">maximum</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
    <span class="k">elif</span> <span class="n">maximum</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The maximum value to represent is larger than the range of 64bit integer! This is not easily possible...&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dtype</span></div>


<div class="viewcode-block" id="bin">
<a class="viewcode-back" href="../../../_autosummary/tacco.utils.bin.html#tacco.utils.bin">[docs]</a>
<span class="k">def</span> <span class="nf">bin</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">bin_size</span><span class="p">,</span>
    <span class="n">position_keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">],</span>
    <span class="n">bin_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">shift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Bins points in position space.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data</span>
<span class="sd">        A :class:`~pandas.DataFrame`.</span>
<span class="sd">    bin_size</span>
<span class="sd">        The spatial size of a bin. Bins are of the same size in all</span>
<span class="sd">        dimensions.</span>
<span class="sd">    position_keys</span>
<span class="sd">        Array-like of column keys which contain the position of the points.</span>
<span class="sd">    bin_keys</span>
<span class="sd">        The names of the columns to contain the bin assignment. Has to be of</span>
<span class="sd">        the same length as `position_keys`. If `None`, a dataframe of bin</span>
<span class="sd">        assignments is returned.</span>
<span class="sd">    shift</span>
<span class="sd">        An array-like of the same length as `position_keys`, giving the</span>
<span class="sd">        shift of the start point of the bin grid in every dimension. If</span>
<span class="sd">        `None`, then no shift is used and the bin grid starts at the minimum</span>
<span class="sd">        value in each dimension.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Depending on `bin_key` returns either a :class:`~pandas.DataFrame` of bin\</span>
<span class="sd">    assignments or the updated input `data` contining the bin assignments\</span>
<span class="sd">    under `bin_keys`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_coords</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">position_keys</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">mins</span><span class="p">,</span> <span class="n">maxs</span> <span class="o">=</span> <span class="n">_coords</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">_coords</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mins</span> <span class="o">+=</span> <span class="n">shift</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">max_bin_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxs</span> <span class="o">-</span> <span class="n">mins</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">//</span> <span class="n">bin_size</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">min_dtype</span><span class="p">(</span><span class="n">max_bin_value</span><span class="p">)</span>

    <span class="n">bin_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([((</span><span class="n">_coords</span><span class="p">[:,</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="n">mins</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">//</span> <span class="n">bin_size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dim</span><span class="p">)</span> <span class="p">])</span><span class="o">.</span><span class="n">T</span>

<span class="c1">#    bind = [np.arange(mins[d],maxs[d],bin_size) for d in range(n_dim) ]</span>
<span class="c1">#    counts = np.array([ np.histogramdd(sub[position_keys].to_numpy(), bins=bind)[0] for g, sub in data.groupby(count_key) ])</span>
<span class="c1">#    bin_coords = np.array([x.T for x in np.meshgrid(*[list(range(len(b[:-1]))) for b in bind])])</span>

    <span class="k">if</span> <span class="n">bin_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bin_coords</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;`bin_keys` and `position_keys` have a diferent size: `(len(bin_keys),len(position_keys))=(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_keys</span><span class="p">)</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">n_dim</span><span class="si">}</span><span class="s1">)`&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span><span class="p">,</span><span class="n">bin_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bin_keys</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">bin_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_coords</span><span class="p">[:,</span><span class="n">d</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="hash">
<a class="viewcode-back" href="../../../_autosummary/tacco.utils.hash.html#tacco.utils.hash">[docs]</a>
<span class="k">def</span> <span class="nf">hash</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">hash_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">compress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Create collision-free hash of several categorical columns by</span>
<span class="sd">    lexicograhical indexing.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data</span>
<span class="sd">        A :class:`~pandas.DataFrame`.</span>
<span class="sd">    keys</span>
<span class="sd">        The names of the columns containing the categorical properties to</span>
<span class="sd">        hash. Not-categorical columns are transformed to categoricals first.</span>
<span class="sd">        If `None`, uses all columns.</span>
<span class="sd">    hash_key</span>
<span class="sd">        The name of the column to contain the hash values. If `None`, a series</span>
<span class="sd">        of hash assignments is returned.</span>
<span class="sd">    other</span>
<span class="sd">        Another :class:`~pandas.DataFrame`, which also has the `keys` with the</span>
<span class="sd">        same datatypes and should get the same hash trasformation as `data`.</span>
<span class="sd">    compress</span>
<span class="sd">        Whether to compress the lexicographical indices into contiguous 0-based</span>
<span class="sd">        hash values. This can take quite some time, but can also decrease the</span>
<span class="sd">        object size of the hash columns.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Depending on `hash_key` returns either a :class:`~pandas.Series` of hash\</span>
<span class="sd">    assignments or the updated input `data` contining the hash assignments\</span>
<span class="sd">    under `hash_key`. Depending on `other` returns this as a pair of the\</span>
<span class="sd">    results for `data and `other`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>

    <span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_other</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span>

    <span class="n">colrange</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">cats</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">colrange</span><span class="p">:</span>
        <span class="n">unique</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span><span class="s1">&#39;to_numpy&#39;</span><span class="p">):</span>
            <span class="n">unique</span> <span class="o">=</span> <span class="n">unique</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">_other</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Columns </span><span class="si">{</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">!r}</span><span class="s1"> of `data` and `other` have different data types </span><span class="si">{</span><span class="n">_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">!r}</span><span class="s1"> and </span><span class="si">{</span><span class="n">_other</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">!r}</span><span class="s1">!&#39;</span><span class="p">)</span>
            <span class="n">other_unique</span> <span class="o">=</span> <span class="n">_other</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other_unique</span><span class="p">,</span><span class="s1">&#39;to_numpy&#39;</span><span class="p">):</span>
                <span class="n">other_unique</span> <span class="o">=</span> <span class="n">other_unique</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">unique</span><span class="p">,</span> <span class="n">other_unique</span><span class="p">]))</span>
        
        <span class="n">cats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">unique</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">(</span><span class="n">unique</span><span class="p">)))</span>
    
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">cats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">colrange</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">min_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sizes</span><span class="p">))</span>
    <span class="n">codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">cats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">colrange</span><span class="p">]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">size</span><span class="p">,</span><span class="n">code</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">*=</span> <span class="n">size</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">code</span>

    <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">compress</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>

        <span class="k">if</span> <span class="n">hash_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">hash_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">data</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_cats</span> <span class="o">=</span> <span class="p">[</span><span class="n">_other</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">colrange</span><span class="p">]</span>
        <span class="n">other_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">other_cats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">colrange</span><span class="p">]</span>
        <span class="n">other_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">other_codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">size</span><span class="p">,</span><span class="n">code</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">other_codes</span><span class="p">):</span>
            <span class="n">other_res</span> <span class="o">*=</span> <span class="n">size</span>
            <span class="n">other_res</span> <span class="o">+=</span> <span class="n">code</span>

        <span class="k">if</span> <span class="n">compress</span><span class="p">:</span>
            <span class="n">unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">other_res</span><span class="p">)]))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">(</span><span class="n">unique</span><span class="p">))</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>
            <span class="n">other_res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">other_res</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">(</span><span class="n">unique</span><span class="p">))</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>

        <span class="k">if</span> <span class="n">hash_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">other_res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">hash_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="n">other</span><span class="p">[</span><span class="n">hash_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_res</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">other</span></div>


<span class="k">def</span> <span class="nf">data_copy</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="c1"># reuse indices of sparse matrix, while preseving the original data</span>
        <span class="n">A_data</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">data</span>
        <span class="n">A</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">A_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">A</span>
<span class="k">def</span> <span class="nf">restore_data</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A_data</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="n">A</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">A_data</span>
    
<span class="k">def</span> <span class="nf">kl_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="c1"># dont touch originals ; but only copy data, if sparse</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">A_data</span> <span class="o">=</span> <span class="n">data_copy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">B</span><span class="p">,</span> <span class="n">B_data</span> <span class="o">=</span> <span class="n">data_copy</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    
    <span class="c1"># make rows of A and B probability distributions</span>
    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># KL_ct = sum_g A_cg log(A_cg/B_tg) = sum_g A_cg log(A_cg) - sum_g A_cg log(B_tg)</span>
    <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
        <span class="n">B</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">gemmT</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="n">A</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_A0</span> <span class="o">=</span> <span class="n">A</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">A</span><span class="p">[</span><span class="n">_A0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">_A0</span><span class="p">])</span>
    <span class="n">AA</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># restore original data, if sparse</span>
    <span class="n">restore_data</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A_data</span><span class="p">)</span>
    <span class="n">restore_data</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">B_data</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ABT</span> <span class="o">-</span> <span class="n">AA</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="c1"># change the sign to get positive distances</span>

<span class="k">def</span> <span class="nf">naive_projection</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># make rows of A and B probability distributions</span>
    <span class="c1"># project A on B: values between 0 and 1</span>
    
    <span class="c1"># as scaling and product commute, scale at the end to save memory and computation</span>
    
    <span class="n">Asum</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Bsum</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">gemmT</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    
    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">ABT</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Asum</span><span class="p">)</span>
    <span class="n">_math</span><span class="o">.</span><span class="n">col_scale</span><span class="p">(</span><span class="n">ABT</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Bsum</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ABT</span>

<span class="k">def</span> <span class="nf">naive_projection_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># distance is 1 - projection</span>
    
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">naive_projection</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ABT</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">normalized_weighted_scalar_product</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># normalize as probabilities</span>
    <span class="n">Anorm</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Bnorm</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Anorm</span><span class="p">)</span>
    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Bnorm</span><span class="p">)</span>

    <span class="c1"># get &quot;mean bulk expression&quot;</span>
    <span class="n">Bmean</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">Bmean</span>

    <span class="c1"># scale one of them to get Acg * Btg / Mg</span>
    <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">_math</span><span class="o">.</span><span class="n">col_scale</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">mean</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_math</span><span class="o">.</span><span class="n">col_scale</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">mean</span><span class="p">)</span>

    <span class="c1"># get overlap</span>
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">gemmT</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>

    <span class="c1"># normalize as probabilities</span>
    <span class="n">ABTnorm</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">ABT</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">ABT</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">ABTnorm</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ABT</span>

<span class="k">def</span> <span class="nf">weighted_projection</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># normalize as probabilities</span>
    <span class="n">Anorm</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Bnorm</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Anorm</span><span class="p">)</span>
    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Bnorm</span><span class="p">)</span>

    <span class="c1"># get &quot;mean bulk expression&quot;</span>
    <span class="n">Bmean</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">Bmean</span>

    <span class="n">_mean</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">mean</span>

    <span class="c1"># normalize A and B in the weighted scalar product defined by sum_g x_g * y_g / mean_g</span>
    <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="c1"># reuse indices of sparse matrix, while preseving the original data</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">A_data</span> <span class="o">=</span> <span class="n">data_copy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">A</span><span class="o">.</span><span class="n">data</span>
        <span class="n">Anorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">_mean</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">restore_data</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A_data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Anorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">A</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="n">_mean</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
        <span class="c1"># reuse indices of sparse matrix, while preseving the original data</span>
        <span class="n">B</span><span class="p">,</span> <span class="n">B_data</span> <span class="o">=</span> <span class="n">data_copy</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">B</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">B</span><span class="o">.</span><span class="n">data</span>
        <span class="n">Bnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">@</span> <span class="n">_mean</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">restore_data</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">B_data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Bnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="n">_mean</span><span class="p">)</span>
    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Anorm</span><span class="p">)</span>
    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Bnorm</span><span class="p">)</span>

    <span class="c1"># scale one of them to get Acg * Btg / Mg</span>
    <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">_math</span><span class="o">.</span><span class="n">col_scale</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_mean</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_math</span><span class="o">.</span><span class="n">col_scale</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">_mean</span><span class="p">)</span>

    <span class="c1"># get overlap</span>
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">gemmT</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ABT</span>

<span class="k">def</span> <span class="nf">get_norm</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="c1"># reuse indices of sparse matrix, while preseving the original data</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">A_data</span> <span class="o">=</span> <span class="n">data_copy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">A</span><span class="o">.</span><span class="n">data</span>
        <span class="n">Anorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">restore_data</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A_data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Anorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">A</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Anorm</span>

<span class="k">def</span> <span class="nf">cosine_projection</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">Anorm</span> <span class="o">=</span> <span class="n">get_norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Bnorm</span> <span class="o">=</span> <span class="n">get_norm</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">gemmT</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>

    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">ABT</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Anorm</span><span class="p">)</span>
    <span class="n">_math</span><span class="o">.</span><span class="n">col_scale</span><span class="p">(</span><span class="n">ABT</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Bnorm</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ABT</span>

<span class="c1"># Much faster than scipy.spatial.distance.cdist(A, B, &#39;cosine&#39;) already for dense data.</span>
<span class="c1"># For sparse inputs there is a minimum sparsity necessary to see speedup over the dense version.</span>
<span class="k">def</span> <span class="nf">cosine_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="n">ABT</span> <span class="o">=</span> <span class="n">cosine_projection</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ABT</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bhattacharyya_coefficient</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># normalize as probabilities</span>
    <span class="n">Anorm</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Bnorm</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">get_sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Anorm</span><span class="p">)</span>
    <span class="n">_math</span><span class="o">.</span><span class="n">row_scale</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Bnorm</span><span class="p">)</span>
    
    <span class="c1"># transform to probability amplitudes</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

    <span class="c1"># get overlap</span>
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">gemmT</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ABT</span>

<span class="c1"># bhattacharyya variant of the cosine distance</span>
<span class="c1"># this is identical to the squared hellinger distance</span>
<span class="k">def</span> <span class="nf">bhattacharyya_cosine_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="c1"># get amplitude overlap</span>
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">bhattacharyya_coefficient</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ABT</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">hellinger_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bhattacharyya_cosine_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">bhattacharyya2_coefficient</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="c1"># get amplitude overlap</span>
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">bhattacharyya_coefficient</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    
    <span class="c1"># transform back to probabilities</span>
    <span class="n">ABT</span> <span class="o">*=</span> <span class="n">ABT</span>
    
    <span class="k">return</span> <span class="n">ABT</span>

<span class="c1"># bhattacharyya variant of the cosine distance</span>
<span class="k">def</span> <span class="nf">bhattacharyya2_cosine_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="c1"># get overlap</span>
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">bhattacharyya2_coefficient</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ABT</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_sqnorm</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="c1"># reuse indices of sparse matrix, while preserving the original data</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">A_data</span> <span class="o">=</span> <span class="n">data_copy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">A</span><span class="o">.</span><span class="n">data</span>
        <span class="n">Anorm</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">restore_data</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A_data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Anorm</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Anorm</span>

<span class="c1"># Much faster than scipy.spatial.distance.cdist(A, B, &#39;euclidean&#39;) already for dense data (maybe an epsilon less accurate).</span>
<span class="c1"># For sparse inputs there is a minimum sparsity necessary to see speedup over the dense version.</span>
<span class="k">def</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">Anorm</span> <span class="o">=</span> <span class="n">get_sqnorm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Bnorm</span> <span class="o">=</span> <span class="n">get_sqnorm</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    
    <span class="n">ABT</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">gemmT</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">Anorm</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">+</span><span class="n">Bnorm</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ABT</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

<div class="viewcode-block" id="cdist">
<a class="viewcode-back" href="../../../_autosummary/tacco.utils.cdist.html#tacco.utils.cdist">[docs]</a>
<span class="k">def</span> <span class="nf">cdist</span><span class="p">(</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
    <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w"> </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Calclulate a dense pairwise distance matrix of sparse and dense inputs. For</span>
<span class="sd">    some metrics (&#39;euclidean&#39;, &#39;cosine&#39;), this is considerably faster than</span>
<span class="sd">    :func:`scipy.spatial.distance.cdist`. For basically all other metrics this</span>
<span class="sd">    falls back to :func:`scipy.spatial.distance.cdist`. Special distances are:</span>
<span class="sd">    </span>
<span class="sd">    - &#39;bc&#39;: 1 - Bhattacharyya coefficient, a cosine similarity equivalent for</span>
<span class="sd">      the Bhattacharyya coefficient, which is the overlap of two probability</span>
<span class="sd">      distributions. The input vectors are normalized to sum 1 first.</span>
<span class="sd">    - &#39;bc2&#39;: 1 - (Bhattacharyya coefficient)^2, a cosine similarity equivalent</span>
<span class="sd">      for the squared Bhattacharyya coefficient. The input vectors are</span>
<span class="sd">      normalized to sum 1 first.</span>
<span class="sd">    - &#39;hellinger&#39;: The Hellinger(-Bhattacharyya) distance defined as</span>
<span class="sd">      sqrt(1 - Bhattacharyya coefficient)</span>
<span class="sd">    - &#39;h2&#39;: squared Hellinger Distance; synonymous to &#39;bc&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A</span>
<span class="sd">        A 2d :class:`~numpy.ndarray` or a `scipy` sparse matrix.</span>
<span class="sd">    B</span>
<span class="sd">        A 2d :class:`~numpy.ndarray` or a `scipy` sparse matrix with the same</span>
<span class="sd">        second dimension as `A`. If `None`, use `A`.</span>
<span class="sd">    metric</span>
<span class="sd">        A string specifying the metric to use.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the operation in parallel - if possible.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A :class:`~numpy.ndarray` containing the distances.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">A</span>

    <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`A` and `B` dont have the same second dimension! The shapes are </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    
    <span class="n">A</span><span class="p">,</span><span class="n">B</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">cast_down_common</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;kl&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kl_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;naive&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">naive_projection_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;cosine&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cosine_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">euclidean_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;bc&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;h2&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bhattacharyya_cosine_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;bc2&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bhattacharyya2_cosine_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;hellinger&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hellinger_distance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">A</span><span class="p">):</span> <span class="c1"># scipy.spatial.distance.cdist works only with dense matrices - and we need a dense result anyway...</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span></div>


<div class="viewcode-block" id="projection">
<a class="viewcode-back" href="../../../_autosummary/tacco.utils.projection.html#tacco.utils.projection">[docs]</a>
<span class="k">def</span> <span class="nf">projection</span><span class="p">(</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">B</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;bc&#39;</span><span class="p">,</span>
    <span class="n">deconvolution</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w"> </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Calculate pairwise normalized projections of sparse and dense inputs.</span>
<span class="sd">    Depending on the parameters this can be an asymmetric operation: the</span>
<span class="sd">    argument `A` here is projected on the argument `B`.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A</span>
<span class="sd">        A 2d :class:`~numpy.ndarray` or a `scipy` sparse matrix.</span>
<span class="sd">    B</span>
<span class="sd">        A 2d :class:`~numpy.ndarray` or a `scipy` sparse matrix with the same</span>
<span class="sd">        second dimension as `A`; gives the basis to project on.</span>
<span class="sd">    metric</span>
<span class="sd">        A string specifying the metric to use. Available are</span>
<span class="sd">        </span>
<span class="sd">        - &#39;cosine&#39;: Euclidean projection of normalized vectors</span>
<span class="sd">        - &#39;naive&#39;: Euclidean projection of vectors normalized as probability</span>
<span class="sd">          distributions</span>
<span class="sd">        - &#39;bc&#39;: Bhattacharyya coefficient, which is the overlap of two</span>
<span class="sd">          probability distributions.</span>
<span class="sd">        - &#39;bc2&#39;: squared Bhattacharyya coefficient.</span>
<span class="sd">        </span>
<span class="sd">    deconvolution</span>
<span class="sd">        Which method to use for deconvolution of the projections based on the</span>
<span class="sd">        cross-projections of `B`. If `False`, no deconvolution is done.</span>
<span class="sd">        Available methods are:</span>
<span class="sd">        </span>
<span class="sd">        - &#39;nnls&#39;: solves nnls to get only non-negative deconvolved projections</span>
<span class="sd">        - &#39;linear&#39;: solves a linear system to disentangle contributions; can</span>
<span class="sd">          result in negative values which makes sense for general vectors and</span>
<span class="sd">          amplitudes, i.e.</span>
<span class="sd">          </span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the operation in parallel.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A :class:`~numpy.ndarray` containing the distances.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`A` and `B` dont have the same second dimension! The shapes are </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    
    <span class="n">A</span><span class="p">,</span><span class="n">B</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">cast_down_common</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;cosine&#39;</span><span class="p">:</span>
        <span class="n">projection_function</span> <span class="o">=</span> <span class="n">cosine_projection</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;naive&#39;</span><span class="p">:</span>
        <span class="n">projection_function</span> <span class="o">=</span> <span class="n">naive_projection</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;bc&#39;</span><span class="p">:</span>
        <span class="n">projection_function</span> <span class="o">=</span> <span class="n">bhattacharyya_coefficient</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;bc2&#39;</span><span class="p">:</span>
        <span class="n">projection_function</span> <span class="o">=</span> <span class="n">bhattacharyya2_coefficient</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;nwsp&#39;</span><span class="p">:</span>
        <span class="n">projection_function</span> <span class="o">=</span> <span class="n">normalized_weighted_scalar_product</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;weighted&#39;</span><span class="p">:</span>
        <span class="n">projection_function</span> <span class="o">=</span> <span class="n">weighted_projection</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The `metric` &quot;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s1">&quot; is unknown!&#39;</span><span class="p">)</span>
    
    <span class="c1"># get projections of data on basis</span>
    <span class="n">AB</span> <span class="o">=</span> <span class="n">projection_function</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">deconvolution</span><span class="p">:</span>
        <span class="c1"># get projections of basis on basis (this gives the cross-talk between basis elements)</span>
        <span class="n">BB</span> <span class="o">=</span> <span class="n">projection_function</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">deconvolution</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">AB</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">BB</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">AB</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">assume_a</span><span class="o">=</span><span class="s1">&#39;pos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">elif</span> <span class="n">deconvolution</span> <span class="o">==</span> <span class="s1">&#39;nnls&#39;</span><span class="p">:</span>
            <span class="n">AB</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">parallel_nnls</span><span class="p">(</span><span class="n">BB</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">AB</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The `deconvolution` &quot;</span><span class="si">{</span><span class="n">deconvolution</span><span class="si">}</span><span class="s1">&quot; is unknown!&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">AB</span></div>


<span class="k">def</span> <span class="nf">enum_shifts</span><span class="p">(</span><span class="n">n_shifts</span><span class="p">,</span><span class="n">n_dim</span><span class="p">,</span><span class="n">shifts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shifts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shifts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_shifts</span><span class="p">)</span> <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">shift</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_shifts</span><span class="p">)</span> <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts</span> <span class="p">]</span>
    <span class="k">return</span> <span class="n">enum_shifts</span><span class="p">(</span><span class="n">n_shifts</span><span class="p">,</span><span class="n">n_dim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">)</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_lexicographic_hash</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">sizes</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">size</span><span class="p">,</span><span class="n">code</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">code</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">res</span> <span class="o">*=</span> <span class="n">size</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">code</span>
    <span class="k">return</span> <span class="n">res</span>
        
<span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_numba_getNN</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">shifts</span><span class="p">):</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
    
    <span class="n">xy2bin_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)):</span>
        <span class="n">xy2bin_dict</span><span class="p">[</span><span class="n">_lexicographic_hash</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">sizes</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="c1"># for every coord there can be 3**nDimensions - 1 neighbours contributions</span>
    <span class="c1"># for every coord the first entry is the number of neighbours, adding + 1 to a total of 3**nDimensions</span>
    <span class="n">others</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="o">**</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="n">bins</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)):</span>
        <span class="n">bi</span><span class="p">,</span><span class="n">ci</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">xi</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
        <span class="n">bi_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">:</span>
            <span class="n">bj</span> <span class="o">=</span> <span class="n">xy2bin_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_lexicographic_hash</span><span class="p">(</span><span class="n">ci</span><span class="o">+</span><span class="n">shift</span><span class="p">,</span><span class="n">sizes</span><span class="p">),</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bj</span> <span class="o">&gt;</span> <span class="n">bi</span><span class="p">:</span>
                    <span class="n">bi_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">others</span><span class="p">[</span><span class="n">bi</span><span class="p">,</span><span class="n">bi_counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">bj</span>
        <span class="n">others</span><span class="p">[</span><span class="n">bi</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bi_counter</span>
    
    <span class="k">return</span> <span class="n">others</span>

<span class="k">def</span> <span class="nf">_python_getNN</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">shifts</span><span class="p">):</span>
    
    <span class="n">xy2bin_dict</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ci</span><span class="p">):</span><span class="n">bi</span> <span class="k">for</span> <span class="n">ci</span><span class="p">,</span><span class="n">bi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">bins</span><span class="p">)}</span>
    
    <span class="k">def</span> <span class="nf">_getHyperCube</span><span class="p">(</span><span class="n">xy2bin_dict</span><span class="p">,</span><span class="n">ci</span><span class="p">,</span><span class="n">shifts</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">:</span>
            <span class="n">add</span> <span class="o">=</span> <span class="n">xy2bin_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ci</span><span class="o">+</span><span class="n">shift</span><span class="p">),</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    
    <span class="c1"># for every coord there can be 3**nDimensions - 1 neighbours contributions</span>
    <span class="c1"># for every coord the first entry is the number of neighbours, adding + 1 to a total of 3**nDimensions</span>
    <span class="n">others</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="o">**</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="n">bins</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ci</span><span class="p">,</span><span class="n">bi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">bins</span><span class="p">):</span>
        <span class="n">bi_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bj</span> <span class="ow">in</span> <span class="n">_getHyperCube</span><span class="p">(</span><span class="n">xy2bin_dict</span><span class="p">,</span><span class="n">ci</span><span class="p">,</span><span class="n">shifts</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bj</span> <span class="o">&gt;</span> <span class="n">bi</span><span class="p">:</span>
                <span class="n">bi_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">others</span><span class="p">[</span><span class="n">bi</span><span class="p">,</span><span class="n">bi_counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">bj</span>
        <span class="n">others</span><span class="p">[</span><span class="n">bi</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bi_counter</span>
    
    <span class="k">return</span> <span class="n">others</span>

<span class="n">_numba_experimental_dict</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="k">def</span> <span class="nf">_getNN</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">numba_experimental_dict</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_numba_experimental_dict</span>
    <span class="k">if</span> <span class="n">numba_experimental_dict</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_numba_experimental_dict</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
            <span class="n">_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_x</span><span class="p">,</span><span class="n">_y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            
            <span class="n">result_0</span> <span class="o">=</span> <span class="n">_getNN</span><span class="p">(</span><span class="n">_coords</span><span class="p">,</span> <span class="n">_b</span><span class="p">,</span> <span class="n">numba_experimental_dict</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">result_2</span> <span class="o">=</span> <span class="n">_getNN</span><span class="p">(</span><span class="n">_coords</span><span class="p">,</span> <span class="n">_b</span><span class="p">,</span> <span class="n">numba_experimental_dict</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">result_2</span> <span class="o">==</span> <span class="n">result_0</span><span class="p">):</span>
                <span class="n">_numba_experimental_dict</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result_1</span> <span class="o">=</span> <span class="n">_getNN</span><span class="p">(</span><span class="n">_coords</span><span class="p">,</span> <span class="n">_b</span><span class="p">,</span> <span class="n">numba_experimental_dict</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">result_1</span> <span class="o">==</span> <span class="n">result_0</span><span class="p">):</span>
                    <span class="n">_numba_experimental_dict</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_numba_experimental_dict</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="n">numba_experimental_dict</span> <span class="o">=</span> <span class="n">_numba_experimental_dict</span>
    
    <span class="c1"># shifts in the bin-vector to find all neighbors</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">enum_shifts</span><span class="p">(</span><span class="n">n_shifts</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">n_dim</span><span class="o">=</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">shifts</span><span class="o">-</span><span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">numba_experimental_dict</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">total_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
            <span class="n">total_size</span> <span class="o">=</span> <span class="n">total_size</span> <span class="o">*</span> <span class="n">size</span>
        <span class="k">if</span> <span class="n">total_size</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">63</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The bin hypercube is too large to be enumerated in a 64bit signed integer. The current implementation for `method==&quot;numba&quot;` with `numba_experimental_dict != 0` cant handle this case. Use bigger bins i.e. a larger max_distance, `numba_experimental_dict==0`, or `method==&quot;scipy&quot;.` Falling back to `numba_experimental_dict==0`.&#39;</span><span class="p">)</span>
            <span class="n">numba_experimental_dict</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">numba_experimental_dict</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">binNN</span> <span class="o">=</span> <span class="n">_numba_getNN</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">shifts</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">numba_experimental_dict</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">binNN</span> <span class="o">=</span> <span class="n">_numba_getNN</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="n">bins</span><span class="p">,</span> <span class="n">shifts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">binNN</span> <span class="o">=</span> <span class="n">_python_getNN</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">shifts</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">binNN</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_get_indptr</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span><span class="n">max_bin</span><span class="p">,</span><span class="n">dtype</span><span class="p">):</span>
    <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_bin</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">bin0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bin0</span><span class="p">:</span>
            <span class="n">bin0</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">indptr</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">indptr</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_row_col_data</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">whole_col</span><span class="p">):</span>
    
    <span class="n">total_obs</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">row</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">total_obs</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">whole_row</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">col</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">total_obs</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">whole_col</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">total_obs</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">distance</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">dij</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dij</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dij</span> <span class="o">&lt;=</span> <span class="n">max_distance</span><span class="p">:</span>
                <span class="n">row</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">whole_row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">col</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">whole_col</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dij</span>
                <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="p">[:</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[:</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">data</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_cdist_euclidean_parallel_</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span> <span class="c1"># cant use this as it runs into a bug in numba https://github.com/numba/numba/issues/7051</span>
    <span class="n">_nA</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">_nB</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">_nA</span><span class="p">,</span><span class="n">_nB</span><span class="p">))</span>
    <span class="c1"># code with constants for important cases enables powerful compiler optimizations</span>
    <span class="k">if</span> <span class="n">_nC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                    <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_nC</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                    <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_nC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                    <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nC</span><span class="p">):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                    <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">D</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_cdist_euclidean_D2_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="n">_nA</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">_nB</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">_nA</span><span class="p">,</span><span class="n">_nB</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
            <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">D</span>
<span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_cdist_euclidean_D3_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="n">_nA</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">_nB</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">_nA</span><span class="p">,</span><span class="n">_nB</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
            <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">D</span>
<span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_cdist_euclidean_D1_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="n">_nA</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">_nB</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">_nA</span><span class="p">,</span><span class="n">_nB</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
            <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">D</span>
<span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_cdist_euclidean_DN_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="n">_nA</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">_nB</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">_nA</span><span class="p">,</span><span class="n">_nB</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nC</span><span class="p">):</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
            <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">D</span>
<span class="k">def</span> <span class="nf">_cdist_euclidean_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span> <span class="c1"># have to use this until numba bug is resolved https://github.com/numba/numba/issues/7051</span>
    <span class="n">_nA</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">_nB</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># code with constants for important cases enables powerful compiler optimizations</span>
    <span class="k">if</span> <span class="n">_nC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cdist_euclidean_D2_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_nC</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cdist_euclidean_D3_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_nC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cdist_euclidean_D1_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cdist_euclidean_DN_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_cdist_euclidean_serial</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="n">_nA</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">_nB</span><span class="p">,</span> <span class="n">_nC</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">_nA</span><span class="p">,</span><span class="n">_nB</span><span class="p">))</span>
    <span class="c1"># code with constants for important cases enables powerful compiler optimizations</span>
    <span class="k">if</span> <span class="n">_nC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                    <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_nC</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                    <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_nC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                    <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">_nA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nB</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_nC</span><span class="p">):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
                    <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">D</span>

<div class="viewcode-block" id="dense_distance_matrix">
<a class="viewcode-back" href="../../../_autosummary/tacco.utils.dense_distance_matrix.html#tacco.utils.dense_distance_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">dense_distance_matrix</span><span class="p">(</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Calclulate a dense pairwise euclidean distance matrix of dense inputs.</span>
<span class="sd">    Compared to :func:`tacco.tools.cdist` this has a few extra optimizations for 1D-3D</span>
<span class="sd">    data - and only works for dense inputs.</span>

<span class="sd">    For a sparse version, see :func:`~tacco.utils.sparse_distance_matrix`.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A</span>
<span class="sd">        A 2d :class:`~numpy.ndarray`.</span>
<span class="sd">    B</span>
<span class="sd">        A 2d :class:`~numpy.ndarray` with the same second dimension as `A`.</span>
<span class="sd">        If `None`, use `A`.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the operation in parallel.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A :class:`~numpy.ndarray` containing the distances.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">A</span>

    <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`A` and `B` dont have the same second dimension! The shapes are </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    
    <span class="n">A</span><span class="p">,</span><span class="n">B</span> <span class="o">=</span> <span class="n">_math</span><span class="o">.</span><span class="n">cast_down_common</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cdist_euclidean_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cdist_euclidean_serial</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span></div>


<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_run_single</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN_i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rowNN</span><span class="p">,</span> <span class="n">colNN</span><span class="p">,</span> <span class="n">dataNN</span><span class="p">):</span>
    
    <span class="n">_whole_row</span> <span class="o">=</span> <span class="n">whole_row</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">_pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
    <span class="c1"># calculate distances within bin</span>
    <span class="n">_distance</span> <span class="o">=</span> <span class="n">_cdist_euclidean_serial</span><span class="p">(</span><span class="n">_pos</span><span class="p">,</span><span class="n">_pos</span><span class="p">)</span>
    <span class="n">_row</span><span class="p">,</span><span class="n">_col</span><span class="p">,</span><span class="n">_data</span> <span class="o">=</span> <span class="n">_row_col_data</span><span class="p">(</span><span class="n">_distance</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">_whole_row</span><span class="p">,</span> <span class="n">_whole_row</span><span class="p">)</span>
    
    <span class="n">c1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_row</span><span class="p">)</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_row</span><span class="p">)</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="n">c1</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_row</span>
    <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">c1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_col</span>
    <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">c1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_data</span>

    <span class="n">c0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">binNN_i</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">binNN_i</span><span class="p">:</span>
        <span class="c1"># calculate distances to neighbour bins</span>
        <span class="n">_whole_col</span> <span class="o">=</span> <span class="n">whole_row</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span><span class="n">indptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">_posNN</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span><span class="n">indptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">_distance</span> <span class="o">=</span> <span class="n">_cdist_euclidean_serial</span><span class="p">(</span><span class="n">_pos</span><span class="p">,</span> <span class="n">_posNN</span><span class="p">)</span>
        <span class="n">_row</span><span class="p">,</span><span class="n">_col</span><span class="p">,</span><span class="n">_data</span> <span class="o">=</span> <span class="n">_row_col_data</span><span class="p">(</span><span class="n">_distance</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">_whole_row</span><span class="p">,</span> <span class="n">_whole_col</span><span class="p">)</span>
    
        <span class="n">c1</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">_row</span><span class="p">)</span>
        <span class="n">rowNN</span><span class="p">[(</span><span class="n">c0</span><span class="o">+</span><span class="mi">1</span><span class="p">):(</span><span class="n">c1</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_row</span>
        <span class="n">colNN</span><span class="p">[</span><span class="n">c0</span><span class="p">:</span><span class="n">c1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_col</span>
        <span class="n">dataNN</span><span class="p">[</span><span class="n">c0</span><span class="p">:</span><span class="n">c1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_data</span>
        <span class="n">c0</span> <span class="o">=</span> <span class="n">c1</span>
    <span class="n">rowNN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c0</span>
    
<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_run_batch</span><span class="p">(</span><span class="n">i_range</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">_row</span><span class="p">,</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_rowNN</span><span class="p">,</span> <span class="n">_colNN</span><span class="p">,</span> <span class="n">_dataNN</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_range</span><span class="p">)):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_range</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span>
        <span class="n">li</span> <span class="o">=</span> <span class="n">load_balance_ordering</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">binNN_i</span> <span class="o">=</span> <span class="n">binNN</span><span class="p">[</span><span class="n">li</span><span class="p">,</span><span class="mi">1</span><span class="p">:(</span><span class="n">binNN</span><span class="p">[</span><span class="n">li</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">_run_single</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN_i</span><span class="p">,</span> <span class="n">_row</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">_col</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">_data</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">_rowNN</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">_colNN</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">_dataNN</span><span class="p">[</span><span class="n">_i</span><span class="p">])</span>
<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_run_batch_serial</span><span class="p">(</span><span class="n">i_range</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">_row</span><span class="p">,</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_rowNN</span><span class="p">,</span> <span class="n">_colNN</span><span class="p">,</span> <span class="n">_dataNN</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_range</span><span class="p">)):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_range</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span>
        <span class="n">li</span> <span class="o">=</span> <span class="n">load_balance_ordering</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">binNN_i</span> <span class="o">=</span> <span class="n">binNN</span><span class="p">[</span><span class="n">li</span><span class="p">,</span><span class="mi">1</span><span class="p">:(</span><span class="n">binNN</span><span class="p">[</span><span class="n">li</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">_run_single</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN_i</span><span class="p">,</span> <span class="n">_row</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">_col</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">_data</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">_rowNN</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">_colNN</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">_dataNN</span><span class="p">[</span><span class="n">_i</span><span class="p">])</span>
    
<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_run_batch_balanced_core</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">balance_indptr</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">_row</span><span class="p">,</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_rowNN</span><span class="p">,</span> <span class="n">_colNN</span><span class="p">,</span> <span class="n">_dataNN</span><span class="p">):</span>
    <span class="n">n_extra</span> <span class="o">=</span> <span class="n">balance_indptr</span><span class="p">[</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">balance_indptr</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="n">i_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">n_extra</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">load_balance_ordering</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> 
    <span class="n">i_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">i_range</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="mi">1</span><span class="o">+</span><span class="n">n_extra</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">balance_indptr</span><span class="p">[</span><span class="n">b</span><span class="p">],</span><span class="n">balance_indptr</span><span class="p">[</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">offsetNN</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_range</span><span class="p">)):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i_range</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span>
        <span class="n">li</span> <span class="o">=</span> <span class="n">load_balance_ordering</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">binNN_i</span> <span class="o">=</span> <span class="n">binNN</span><span class="p">[</span><span class="n">li</span><span class="p">,</span><span class="mi">1</span><span class="p">:(</span><span class="n">binNN</span><span class="p">[</span><span class="n">li</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

        <span class="n">_row0</span> <span class="o">=</span> <span class="n">_row</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="c1"># save the last entries of the rows: will be overwritten by the number of results</span>
        <span class="n">_rowNN0</span> <span class="o">=</span> <span class="n">_rowNN</span><span class="p">[</span><span class="n">offsetNN</span><span class="p">]</span>
        <span class="n">_run_single</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN_i</span><span class="p">,</span>
                    <span class="n">_row</span><span class="p">[</span><span class="n">offset</span><span class="p">:],</span> <span class="n">_col</span><span class="p">[</span><span class="n">offset</span><span class="p">:],</span> <span class="n">_data</span><span class="p">[</span><span class="n">offset</span><span class="p">:],</span>
                    <span class="n">_rowNN</span><span class="p">[</span><span class="n">offsetNN</span><span class="p">:],</span> <span class="n">_colNN</span><span class="p">[</span><span class="n">offsetNN</span><span class="p">:],</span> <span class="n">_dataNN</span><span class="p">[</span><span class="n">offsetNN</span><span class="p">:],</span>
                   <span class="p">)</span>

        <span class="n">new_results</span> <span class="o">=</span> <span class="n">_row</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
        <span class="n">new_resultsNN</span> <span class="o">=</span> <span class="n">_rowNN</span><span class="p">[</span><span class="n">offsetNN</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># restore the last entries of the rows</span>
            <span class="n">_row</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">_row0</span>
            <span class="n">_rowNN</span><span class="p">[</span><span class="n">offsetNN</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rowNN0</span>

        <span class="n">offset</span> <span class="o">+=</span> <span class="n">new_results</span>
        <span class="n">offsetNN</span> <span class="o">+=</span> <span class="n">new_resultsNN</span>
    <span class="c1"># write the total number of results</span>
    <span class="n">_row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
    <span class="n">_rowNN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">offsetNN</span>
    
<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_run_batch_balanced</span><span class="p">(</span><span class="n">b_range</span><span class="p">,</span> <span class="n">balance_indptr</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rowNN</span><span class="p">,</span> <span class="n">colNN</span><span class="p">,</span> <span class="n">dataNN</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_b</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b_range</span><span class="p">)):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b_range</span><span class="p">[</span><span class="n">_b</span><span class="p">]</span>
        <span class="n">_run_batch_balanced_core</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">balance_indptr</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">_b</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="n">_b</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">_b</span><span class="p">],</span> <span class="n">rowNN</span><span class="p">[</span><span class="n">_b</span><span class="p">],</span> <span class="n">colNN</span><span class="p">[</span><span class="n">_b</span><span class="p">],</span> <span class="n">dataNN</span><span class="p">[</span><span class="n">_b</span><span class="p">])</span>
    
<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_run_batch_balanced_serial</span><span class="p">(</span><span class="n">b_range</span><span class="p">,</span> <span class="n">balance_indptr</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rowNN</span><span class="p">,</span> <span class="n">colNN</span><span class="p">,</span> <span class="n">dataNN</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_b</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b_range</span><span class="p">)):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b_range</span><span class="p">[</span><span class="n">_b</span><span class="p">]</span>
        <span class="n">_run_batch_balanced_core</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">balance_indptr</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">_b</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="n">_b</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">_b</span><span class="p">],</span> <span class="n">rowNN</span><span class="p">[</span><span class="n">_b</span><span class="p">],</span> <span class="n">colNN</span><span class="p">[</span><span class="n">_b</span><span class="p">],</span> <span class="n">dataNN</span><span class="p">[</span><span class="n">_b</span><span class="p">])</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_max_n_i</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">bin_batching</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indptr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">max_n_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_batching</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">max_n_i_NN</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_batching</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">binNN</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">all_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">all_n_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">all_n_i_NN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">n_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">n_i</span> <span class="o">*=</span> <span class="n">n_i</span>
        <span class="k">if</span> <span class="n">n_i</span> <span class="o">&gt;</span> <span class="n">max_n_i</span><span class="p">:</span>
            <span class="n">max_n_i</span> <span class="o">=</span> <span class="n">n_i</span>

        <span class="n">binNN_i_N</span> <span class="o">=</span> <span class="n">binNN</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">binNN_i</span> <span class="o">=</span> <span class="n">binNN</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:(</span><span class="n">binNN_i_N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        
        <span class="n">n_binNN_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">binNN_i</span><span class="p">:</span>
            <span class="n">n_binNN_i</span> <span class="o">+=</span> <span class="n">indptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">indptr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">n_binNN_i</span> <span class="o">*=</span> <span class="nb">int</span><span class="p">(</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">max_n_i_NN</span> <span class="o">&lt;</span> <span class="n">n_binNN_i</span><span class="p">:</span>
            <span class="n">max_n_i_NN</span> <span class="o">=</span> <span class="n">n_binNN_i</span>
            
        <span class="n">all_n_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_i</span>
        <span class="n">all_n_i_NN</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_binNN_i</span>
        
        <span class="n">all_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_i</span> <span class="o">+</span> <span class="n">n_binNN_i</span> <span class="c1"># this should be proportional to the dense distance calculation cost - and (a bit above) the maximum distance storage requirement</span>

    <span class="c1"># sort the bins by cost: makes calculation in bunches better load balanced</span>
    <span class="n">ordering</span> <span class="o">=</span> <span class="n">all_max</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    
    <span class="c1"># create batches of a single expensive and (many) small ones to make the batches have a near equal cost</span>
    <span class="c1"># a batch `i` consists of a large bin `ordering[-i]` and the small ones indicated by `ordering[indptr[i]:indptr[i+1]]`</span>
    <span class="n">balance_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ordering</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">back_id</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">front_id</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">balance_indptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">batch_id</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">back_id</span> <span class="o">&gt;=</span> <span class="n">front_id</span><span class="p">:</span>
        <span class="n">current_size</span> <span class="o">=</span> <span class="n">all_n_i</span><span class="p">[</span><span class="n">ordering</span><span class="p">[</span><span class="n">back_id</span><span class="p">]]</span>
        <span class="n">next_size</span> <span class="o">=</span> <span class="n">all_n_i</span><span class="p">[</span><span class="n">ordering</span><span class="p">[</span><span class="n">front_id</span><span class="p">]]</span>
        <span class="n">current_size_NN</span> <span class="o">=</span> <span class="n">all_n_i_NN</span><span class="p">[</span><span class="n">ordering</span><span class="p">[</span><span class="n">back_id</span><span class="p">]]</span>
        <span class="n">next_size_NN</span> <span class="o">=</span> <span class="n">all_n_i_NN</span><span class="p">[</span><span class="n">ordering</span><span class="p">[</span><span class="n">front_id</span><span class="p">]]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">current_size</span> <span class="o">+</span> <span class="n">next_size</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_n_i</span> <span class="ow">and</span> <span class="p">(</span><span class="n">current_size_NN</span> <span class="o">+</span> <span class="n">next_size_NN</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_n_i_NN</span> <span class="ow">and</span> <span class="n">back_id</span> <span class="o">&gt;</span> <span class="n">front_id</span><span class="p">:</span>
            <span class="n">current_size</span> <span class="o">+=</span> <span class="n">next_size</span>
            <span class="n">front_id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">next_size</span> <span class="o">=</span> <span class="n">all_max</span><span class="p">[</span><span class="n">ordering</span><span class="p">[</span><span class="n">front_id</span><span class="p">]]</span>
        <span class="n">balance_indptr</span><span class="p">[</span><span class="n">batch_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">front_id</span>
        <span class="n">batch_id</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">back_id</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">balance_indptr</span> <span class="o">=</span> <span class="n">balance_indptr</span><span class="p">[:</span><span class="n">batch_id</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1">#print(&#39;number of points/bins/jobs:&#39;, indptr[-1], &#39;/&#39;, n, &#39;/&#39;, len(balance_indptr)-1)</span>
    <span class="c1">#print(all_max)</span>
    <span class="c1">#print(all_max[ordering])</span>
    <span class="c1">#print(ordering, indptr)</span>
    <span class="c1">#for i in range(len(indptr)-1):</span>
    <span class="c1">#    print(ordering[-i-1], all_max[ordering[-i-1]], ordering[indptr[i]:indptr[i+1]], all_max[ordering[indptr[i]:indptr[i+1]]])</span>
    
    <span class="k">return</span> <span class="n">max_n_i</span><span class="p">,</span> <span class="n">max_n_i_NN</span><span class="p">,</span> <span class="n">ordering</span><span class="p">,</span> <span class="n">balance_indptr</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_collect_results</span><span class="p">(</span><span class="n">_row</span><span class="p">,</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_rowNN</span><span class="p">,</span> <span class="n">_colNN</span><span class="p">,</span> <span class="n">_dataNN</span><span class="p">):</span>
    <span class="c1"># first sweep: check how much space is needed</span>
    <span class="n">n_total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_buffer</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_row</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_buffer</span><span class="p">):</span>
        <span class="n">n_total</span> <span class="o">+=</span> <span class="n">_row</span><span class="p">[</span><span class="n">_i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_total</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_rowNN</span><span class="p">[</span><span class="n">_i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># account for distance symmetry</span>
    
    <span class="c1"># allocate memory</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_total</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_row</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_total</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_col</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_total</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    
    <span class="c1"># second sweep: do actual collection</span>
    <span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_buffer</span><span class="p">):</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">_row</span><span class="p">[</span><span class="n">_i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">c1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">+</span> <span class="n">c1</span>
            <span class="n">row</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_row</span><span class="p">[</span><span class="n">_i</span><span class="p">,</span><span class="mi">1</span><span class="p">:(</span><span class="n">c1</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">col</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_col</span><span class="p">[</span><span class="n">_i</span><span class="p">,:</span><span class="n">c1</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_data</span><span class="p">[</span><span class="n">_i</span><span class="p">,:</span><span class="n">c1</span><span class="p">]</span>
            <span class="n">r0</span> <span class="o">=</span> <span class="n">r1</span>

        <span class="n">c1</span> <span class="o">=</span> <span class="n">_rowNN</span><span class="p">[</span><span class="n">_i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">c1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">+</span> <span class="n">c1</span>
            <span class="n">row</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rowNN</span><span class="p">[</span><span class="n">_i</span><span class="p">,</span><span class="mi">1</span><span class="p">:(</span><span class="n">c1</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">col</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_colNN</span><span class="p">[</span><span class="n">_i</span><span class="p">,:</span><span class="n">c1</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_dataNN</span><span class="p">[</span><span class="n">_i</span><span class="p">,:</span><span class="n">c1</span><span class="p">]</span>
            <span class="n">r0</span> <span class="o">=</span> <span class="n">r1</span>
            <span class="c1"># add the same result also for the transposed bin neighbour combination</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">+</span> <span class="n">c1</span>
            <span class="n">col</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rowNN</span><span class="p">[</span><span class="n">_i</span><span class="p">,</span><span class="mi">1</span><span class="p">:(</span><span class="n">c1</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">row</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_colNN</span><span class="p">[</span><span class="n">_i</span><span class="p">,:</span><span class="n">c1</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_dataNN</span><span class="p">[</span><span class="n">_i</span><span class="p">,:</span><span class="n">c1</span><span class="p">]</span>
            <span class="n">r0</span> <span class="o">=</span> <span class="n">r1</span>
    
    <span class="k">return</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">_run_all</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">parallel</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">bin_batching</span><span class="p">,</span> <span class="n">buffer_directory</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">max_n_i</span><span class="p">,</span> <span class="n">max_n_binNN_i</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">balance_indptr</span> <span class="o">=</span> <span class="n">_max_n_i</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">bin_batching</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">bin_batching</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">balance_indptr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indptr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        
    <span class="n">last_batch_size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">batch_size</span>
    <span class="n">n_batches</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="n">batch_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">last_batch_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">shape0</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="n">_row</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">shape0</span><span class="p">,</span><span class="n">max_n_i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">whole_row</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">_col</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">shape0</span><span class="p">,</span><span class="n">max_n_i</span>  <span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">whole_row</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">shape0</span><span class="p">,</span><span class="n">max_n_i</span>  <span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">pos</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">_rowNN</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">shape0</span><span class="p">,</span><span class="n">max_n_binNN_i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">whole_row</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">_colNN</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">shape0</span><span class="p">,</span><span class="n">max_n_binNN_i</span>  <span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">whole_row</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">_dataNN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">shape0</span><span class="p">,</span><span class="n">max_n_binNN_i</span>  <span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">pos</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    
    <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">col</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_batches</span><span class="p">):</span>
        <span class="n">i_start</span> <span class="o">=</span> <span class="n">batch</span><span class="o">*</span><span class="n">batch_size</span>
        <span class="k">if</span> <span class="n">batch</span> <span class="o">==</span> <span class="n">n_batches</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">last_batch_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_start</span> <span class="o">+</span> <span class="n">last_batch_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_start</span> <span class="o">+</span> <span class="n">batch_size</span>
        <span class="n">i_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i_start</span><span class="p">,</span><span class="n">i_end</span><span class="p">)</span>

        <span class="n">_row</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">_rowNN</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">bin_batching</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
                <span class="n">_run_batch_balanced</span><span class="p">(</span><span class="n">i_range</span><span class="p">,</span> <span class="n">balance_indptr</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">_row</span><span class="p">,</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_rowNN</span><span class="p">,</span> <span class="n">_colNN</span><span class="p">,</span> <span class="n">_dataNN</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_run_batch_balanced_serial</span><span class="p">(</span><span class="n">i_range</span><span class="p">,</span> <span class="n">balance_indptr</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">_row</span><span class="p">,</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_rowNN</span><span class="p">,</span> <span class="n">_colNN</span><span class="p">,</span> <span class="n">_dataNN</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
                <span class="n">_run_batch</span><span class="p">(</span><span class="n">i_range</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">_row</span><span class="p">,</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_rowNN</span><span class="p">,</span> <span class="n">_colNN</span><span class="p">,</span> <span class="n">_dataNN</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_run_batch_serial</span><span class="p">(</span><span class="n">i_range</span><span class="p">,</span> <span class="n">load_balance_ordering</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">_row</span><span class="p">,</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_rowNN</span><span class="p">,</span> <span class="n">_colNN</span><span class="p">,</span> <span class="n">_dataNN</span><span class="p">)</span>

        <span class="n">__row</span><span class="p">,</span> <span class="n">__col</span><span class="p">,</span> <span class="n">__data</span> <span class="o">=</span> <span class="n">_collect_results</span><span class="p">(</span><span class="n">_row</span><span class="p">,</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_rowNN</span><span class="p">,</span> <span class="n">_colNN</span><span class="p">,</span> <span class="n">_dataNN</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">__row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">buffer_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">__row</span><span class="p">)</span>
                <span class="n">col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">__col</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">__data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;row.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">__row</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;col.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">__col</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;data.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">__data</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">__row</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">_guess_blocksize</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># find a blocksize large enough that the &quot;max&quot; block has at a high but not too high number of points to make dense subproblems efficient while keeping memory low and sparsity gain high.</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">maxN</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">factor_i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">blocks</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">numba_blocksize</span> <span class="o">=</span> <span class="n">max_distance</span>
    <span class="k">while</span> <span class="n">maxN</span> <span class="o">&lt;</span> <span class="mi">200</span> <span class="ow">and</span> <span class="n">blocks</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">factor_i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">factor_i</span><span class="o">/</span><span class="n">n_dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span> <span class="c1"># different ballpark...</span>
            <span class="k">break</span>
        <span class="n">numba_blocksize</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">max_distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">factor_i</span><span class="o">/</span><span class="n">n_dim</span><span class="p">)</span><span class="si">:</span><span class="s1">.1e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="c1"># round to 2 significant digits for convenience</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="n">numba_blocksize</span><span class="p">,</span> <span class="n">position_keys</span><span class="o">=</span><span class="n">positions</span><span class="o">.</span><span class="n">columns</span><span class="p">);</span>
        <span class="n">hashes</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">bins</span><span class="p">);</span>
        <span class="n">Avc</span> <span class="o">=</span> <span class="n">hashes</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="n">maxN</span> <span class="o">=</span> <span class="n">Avc</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Avc</span><span class="p">)</span>
    <span class="n">factor_i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">numba_blocksize</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">max_distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">factor_i</span><span class="o">/</span><span class="n">n_dim</span><span class="p">)</span><span class="si">:</span><span class="s1">.1e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="c1"># round to 2 significant digits for convenience</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The heuristic value for the parameter `numba_blocksize` is </span><span class="si">{</span><span class="n">numba_blocksize</span><span class="si">}</span><span class="s1">. Consider specifying this directly as argument to avoid (possibly significant) overhead and/or experiment with this value on (a subset of) the actual dataset at hand to obtain an optimal value in terms of speed and memory requirements.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numba_blocksize</span>

<span class="k">def</span> <span class="nf">_numba_sparse_distance_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">numba_blocksize</span><span class="p">,</span> <span class="n">numba_experimental_dict</span><span class="p">,</span> <span class="n">parallel</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">bin_batching</span><span class="p">,</span> <span class="n">low_mem</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">A</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    
    <span class="n">keys</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">bin_keys</span> <span class="o">=</span> <span class="n">keys</span> <span class="o">+</span> <span class="s1">&#39;_bin&#39;</span>
    <span class="n">bin_key</span> <span class="o">=</span> <span class="s1">&#39;bin&#39;</span>

    <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">numba</span><span class="o">.</span><span class="n">get_num_threads</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">numba_blocksize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">numba_blocksize</span> <span class="o">=</span> <span class="n">_guess_blocksize</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">keys</span><span class="p">],</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">bin_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="nb">bin</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="n">numba_blocksize</span><span class="p">,</span> <span class="n">position_keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">bin_keys</span><span class="o">=</span><span class="n">bin_keys</span><span class="p">);</span>
        <span class="nb">hash</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">bin_keys</span><span class="p">,</span> <span class="n">hash_key</span><span class="o">=</span><span class="n">bin_key</span><span class="p">);</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">bin_key</span><span class="p">)</span>
    
    <span class="c1"># get mapping from bin to all the neighbours with binID larger than itself</span>
    <span class="n">binA</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">bin_key</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">bin_key</span><span class="p">)</span>
    <span class="n">binNN</span> <span class="o">=</span> <span class="n">_getNN</span><span class="p">(</span><span class="n">binA</span><span class="p">[</span><span class="n">bin_keys</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">binA</span><span class="p">[</span><span class="n">bin_key</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">numba_experimental_dict</span><span class="p">)</span>

    <span class="n">indptr</span> <span class="o">=</span> <span class="n">_get_indptr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">bin_key</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span><span class="n">A</span><span class="p">[</span><span class="n">bin_key</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">min_dtype</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span>

    <span class="n">nobs</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">whole_row</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
        <span class="n">tempdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;temp_sparse_distance_matrix_&#39;</span><span class="p">,</span><span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">buffer_directory</span> <span class="o">=</span> <span class="n">tempdir</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">buffer_directory</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># make the matrix-vector product deep in the euclidean metric run single threaded to use more efficient higher level paralellism</span>
        <span class="k">with</span> <span class="n">threadpool_limits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;blas&#39;</span><span class="p">):</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">_run_all</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">whole_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">binNN</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">bin_batching</span><span class="o">=</span><span class="n">bin_batching</span><span class="p">,</span> <span class="n">buffer_directory</span><span class="o">=</span><span class="n">buffer_directory</span><span class="p">)</span>

        <span class="c1"># this way of constructing a coo_matrix has slightly less overhead... </span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">nobs</span><span class="p">,</span><span class="n">nobs</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">buffer_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">distance</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                <span class="n">distance</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="n">distance</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">distance</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;row.bin&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">whole_row</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">distance</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;col.bin&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">whole_row</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">distance</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">buffer_directory</span><span class="o">+</span><span class="s1">&#39;data.bin&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pos</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">low_mem</span><span class="p">:</span>
            <span class="n">tempdir</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">distance</span>

<div class="viewcode-block" id="sparse_distance_matrix">
<a class="viewcode-back" href="../../../_autosummary/tacco.utils.sparse_distance_matrix.html#tacco.utils.sparse_distance_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">sparse_distance_matrix</span><span class="p">(</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">max_distance</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;numba&#39;</span><span class="p">,</span>
    <span class="n">numba_blocksize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">numba_experimental_dict</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">bin_batching</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="n">low_mem</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w"> </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Calclulate a sparse pairwise distance matrix of dense inputs. Only</span>
<span class="sd">    euclidean metric is supported.</span>

<span class="sd">    For a dense version, see :func:`~tacco.utils.dense_distance_matrix`.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A</span>
<span class="sd">        A 2d :class:`~numpy.ndarray`.</span>
<span class="sd">    max_distance</span>
<span class="sd">        A distance cutoff: all distances larger than this value are excluded</span>
<span class="sd">        from the result.</span>
<span class="sd">    method</span>
<span class="sd">        A string indicating the method to use. Available are:</span>
<span class="sd">        </span>
<span class="sd">        - &#39;scipy&#39;: Use :func:`scipy.spatial.cKDTree.sparse_distance_matrix`.</span>
<span class="sd">          This is most efficient for not too many points and relatively small</span>
<span class="sd">          `max_distance`.</span>
<span class="sd">        - &#39;numba&#39;: Use a custom `numba` based implementation, which is much</span>
<span class="sd">          faster for larger `max_distance` and datasets.</span>
<span class="sd">    numba_blocksize</span>
<span class="sd">        If `method` is &#39;numba&#39;, this gives the size of the blocks within which</span>
<span class="sd">        the distances should be computed densely. Has to be at least</span>
<span class="sd">        `max_distance` and - depending on the dataset - should be several times</span>
<span class="sd">        larger for optimal performance. If `None`, use a heuristic to find a</span>
<span class="sd">        reasonable value. Smaller values need less memory.</span>
<span class="sd">    numba_experimental_dict</span>
<span class="sd">        If `method` is &#39;numba&#39;, how to accelerate some parts of the code by</span>
<span class="sd">        using numba dictionaries, which is an experimental numba feature. If</span>
<span class="sd">        &#39;auto&#39;, runs a small test set to determine whether numba dicts seem to</span>
<span class="sd">        work and uses them accordingly.</span>
<span class="sd">    dtype</span>
<span class="sd">        The data type to use for calculations. Internally method &#39;scipy&#39; always</span>
<span class="sd">        uses `np.float64`, i.e. double precision. Method &#39;numba&#39; can get a</span>
<span class="sd">        significant speedup from using lower precision - which can also lead to</span>
<span class="sd">        rounding errors making different nearby points have numerically 0</span>
<span class="sd">        distance, which is then discarded in the sparse result... All</span>
<span class="sd">        non-floating dtypes will be casted to `np.float64`.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run using multiple cores. Only method &#39;numba&#39; supports this</span>
<span class="sd">        option.</span>
<span class="sd">    batch_size</span>
<span class="sd">        The number of blocks to calculate per batch. Small values need less</span>
<span class="sd">        memory while large values tend to give higher parallel speedup. If</span>
<span class="sd">        `None`, uses the number of available threads - even if</span>
<span class="sd">        `parallel==False` and only a single thread is used.</span>
<span class="sd">    bin_batching</span>
<span class="sd">        If larger than `0`, the calculations for individual blocks are grouped</span>
<span class="sd">        such that (mostly) at least `bin_batching` points are considered</span>
<span class="sd">        together. This reduces overhead and the impact of choosing a too small</span>
<span class="sd">        `numba_blocksize`.</span>
<span class="sd">    low_mem</span>
<span class="sd">        Whether to access harddisc to buffer big temporaries. This is slower</span>
<span class="sd">        than in memory operations, but can reduce the memory consumption by</span>
<span class="sd">        a factor of 2.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A :class:`~scipy.sparse.coo_matrix` containing the distances.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`A` has to be an numpy.ndarray!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_float_dtype</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;scipy&#39;</span><span class="p">:</span>
        <span class="n">kd_tree</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">kd_tree</span><span class="o">.</span><span class="n">sparse_distance_matrix</span><span class="p">(</span><span class="n">kd_tree</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">)</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>

        <span class="n">distance</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;numba&#39;</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">numba_blocksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">numba_blocksize</span> <span class="o">&lt;</span> <span class="n">max_distance</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`numba_blocksize &lt; max_distance`&#39;</span><span class="p">)</span>
        
        <span class="n">distance</span> <span class="o">=</span> <span class="n">_numba_sparse_distance_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">numba_blocksize</span><span class="p">,</span> <span class="n">numba_experimental_dict</span><span class="o">=</span><span class="n">numba_experimental_dict</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">bin_batching</span><span class="o">=</span><span class="n">bin_batching</span><span class="p">,</span> <span class="n">low_mem</span><span class="o">=</span><span class="n">low_mem</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;`method` &quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1">&quot; is unknown!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">distance</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">distance</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Broad Institute.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>